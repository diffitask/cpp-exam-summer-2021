## Немного про reordering (off-top)
Рассмотрим такой пример
```cpp
#include <chrono>
#include <iostream>
#include <thread>

#pragma GCC optimize("-O0")

int main() {
    int data = 0;
    bool finished = false;

    std::thread t([&]() {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        // С точки зрения компилятора И процессора следующие две строчки можно свободно менять местами.
        // Никто же не заметит.
        data = 123;
        finished = true;
    });

    while (!finished) {}
    // Разве что другой поток может заметить :(
    std::cout << data << "\n";

    t.join();
}
```
Казалось бы, программа выведет 123, но по факту, может вывести и 0, т.к `finished = true` может случится раньше `data = 123`, А между ними произойти выход из цикла и вывод `data`. Процессор и компилятор может переставлять местами некоторые операции, если посчитает что порядок их выполнения не важен. Так как `mutex` не заблокирован, ничто не сигнализирует о том, как операции должны выполняться. 
## Концепция happens-before

Мы можем говорит о том, что событие А произошло раньше события B, если : 

- А и В происходят в одном потоке, и в рамках одного потока одна операция вызывается раньше другой. (reordering says hi)
- A и B находятся в разных потоках, после того как А случилось в своем потоке и в другом потоке случилось B, их потоки синхронизировались.

В общем случае, после синхронизации потоков, все события до синхронизации в одном потоке стали предшествовать всем событиям произошедшим в другом потоке после синхронизации. 
Базовый пример такой синхронизации:

1.  Ставим m.unlock() в первом потоке
2.  Ставим m.lock() в другом.

Теперь все события до `unlock()` считаются произошедшими до операций совершенных после `lock()`.

Все те события, которые не упорядочены отношением happpens-before, считаются одновременными, даже если на практике они случаются с разницей в минуту. Никто не гарантирует, что так будет выполняться всегда, поэтому при работе над многопоточными программами стоит строго придерживаться этой концепции.  

![alt text](happens-before.png)
 
- На картинке все события B1 происходят до A1 в одном потоке.
- Все события B2 происходят до A2, так как потоки синхронизировались.
- B3 произойдет до A3, все B2 в потоке T3 произойдут до A3.
- Несмотря на то, что по времени A1, A2, A3 выполняются одновременно, мы все еще ничего не можем сказать про их happens-before отношении. 
### Хороший пример использования концепции
```cpp
std::mutex m;

std::thread T1([]() {
    started = true;
    m.lock();
    finished = true;
    m.unlock();
});

std::thread T2([]() {
    m.lock();
    if (finished) {
        assert(started);    
        // Верно, started h-b finished
    }
    m.unlock();
});
```
Важно заметить, что в `T1` не происходит reordering: `started` не окажется выполненым после `m.unlock()`, например. `lock()` и `unlock()` служат сигналом для оптимизатора, что порядок выполнения здесь важен.  

 ### Неочевидный пример нарушения концепции
 ```cpp
 std::thread T1([]() {
    started = true;
    m.lock(); data++; m.unlock();
    finished1 = true;
    finished2 = true;
});

std::thread T2([]() {
    m.lock(); m.unlock();
    if (finished2) { // UB
        assert(finished1);  // Непонятно, UB/reordering
        assert(data > 0);   // Непонятно, UB
        assert(started);    // Непонятно, UB
    }
});
```
Тут, казалось бы, `finished2 = true` выполнится сразу после `finished1 = true`, они даже в одном потоке, но на самом деле мог произойти reodrering, и что из них случится раньше непонятно. Также как и не можем утверждать, что `data++` случится до того, как мы проверим `assert(data > 0)` и аналогично для `assert(started)`.

### Общие советы
- `sleep()` не помогает, строгости тут нет.
- Мьютексы помогают правильно задачть порядок выполнения операций.
- Чем меньше общих ресурсов между потоками, тем лучше. 

## Частичная безопасность shared_ptr
```
*Rem:* `shared_ptr` умный указатель, который хранит ссылку на объект и счетчик владельцев отого объекта. При копировании `shared_ptr` количество владельцев объекта увеличивается, ссылка на объект также копируется. При "уничтожении" одного из `shared_ptr` количество владельцев уменьшается.
```
### Рассмотрим такой пример:
```cpp
#include <shared_ptr>

int main() {
    std::shared_ptr<int> p = std::make_unique(10);

    /* 
    1. Если p передается в потоки как копии shared_ptr,
    то все ок. Shared_ptr потоко безопасен.
    2. Можем поставить одну ссылку, а в другую отправить копию. Так потоки будут рабодать с разными объектами shared_ptr.
    3. Счетчик ссылок потоко безопасен. */


    std::thread t1([/*&*/p]() { 
        for (int i = 0; i < 100'000; i++) {
            auto p2 = p;
            p = p2;
            /* ++*p; а вот это уже нелегально, 
            изменение внутренности shared_ptr 
            не потокобезопасно */
        }
    });

    std::thread t2([/*&*/p]() {
        for (int i = 0; i < 100'000; i++) {
            auto p2 = p;
            p = p2;
            // ++*p; все еще не легально  
        }
    });

    
    t1.join();
    t2.join();

    // Все еще можем добавить mutex
    std::mutex m;

    std::thread t3([&p]() {     // OK
        for (int i = 0; i < 100'000; i++) {
            std::unique_lock l{m};
            auto p2 = p;
            p = p2;
            ++*p; // OK
        }
    });

        
    std::thread t4([&p]() {     // OK
        for (int i = 0; i < 100'000; i++) {
            std::unique_lock l{m};
            auto p2 = p;
            p = p2;
            ++*p; // OK
        }
    });

    t3.join();
    t4.join();
}
```

## Exception-ptr (off-top)

Все исключения выкидываются только в том потоке, где были вызваны. Чтобы перикидывать исключения между потоками можно использовать несколько техник.

```cpp
struct my_exception {
    int value;
};

void foo(int x) {
    throw my_exception{x + 10};
}

int main() {
    /* 1. Не совсем решение, но все же. Если мы запустим асинхронку,
    то при запросе результата ее вычисления через get оно выкинет и
    исключение, если оно произошло во время выполнения. */

    auto f = std::async([]() {
        foo(0);
    });

    try {
        f.get();    // Выкинет исключение, если во время исполнения
                    // что-то пошло не так
    } catch (my_exception &e) {
        std::cout << "e=" << e.value << "\n";
    }

    // 2. Можно использовать exception_ptr
    std::exception_ptr err;  // Похоже на shared_ptr<exception>
    
    auto save_exception = [&]() {
        // В любой момент программы, необязательно непосредственно
        // внутри catch.
        // Если нет текущего исключения - возвращает exception_ptr{}.
        err = std::current_exception();
    };

    try {
        foo(1);
    } catch (...) {
        save_exception();   // Сохраняем текущее исключение
    }

    try {
        if (err) {
            // Перекидываем его еще раз
            std::rethrow_exception(err);  // Требует непустой err.
        } else {
            std::cout << "no exception\n";
        }
    } catch (my_exception &e) {
        std::cout << "e=" << e.value << "\n";
    
```

## Mutable (Off-top)

### Mutable в функциях с пометкой const 
Допустим мы захотели написать атомарный int.
```cpp
struct atomic_int {
    int get() const {
        std::unique_lock l(m);
        return value;
    }

    void set(int new_value) {
        std::unique_lock l(m);
        value = new_value;
    }

private:
    mutable std::mutex m; // mutable здесь важен.
    int value;
};
```
Функция get помечена как const и не может внутри себя изменять состояние обычных полей, а `unique_lock` внутри себя вызывает две модифицирующие функции `m.lock()` и `m.unlock()`. Соответственно, `std::mutex m` обязательно должен быть помечен как mutable, иначе не скомпилируется.

### Еще одно применение mutable: 
Хотим посчитать определитель матрицы, считать ее за куб каждый раз довольно долго, но если матрица не поменялась, то можно матрицу не пересчитывать. Функция подсчета определителя не модифицурует матрицу, поэтому должна быть помечена как `const`, но изменяет кэш. Применим mutable. 
```cpp
struct matrix {
    int determinant() const {
        // Что-то делаем, обновляем last_determinant. 
    }

private:
    int n;
    std::vector<int> data;
    mutable std::optional<int> last_determinant;
};
```

