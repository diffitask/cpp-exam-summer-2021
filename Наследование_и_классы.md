## Наследование и классы

-   Совместимость ссылок и указателей,  `public`/`private`/`protected`  для методов/полей/наследования,  `final`  для структур

### Совместимость ссылок и указателе
```c++
struct Base { // Базовый класс (base) в C++. Родительский/предок/надкласс/суперкласс (Python, Java).
	int x = 10;
};

struct Derived : Base { // Производный класс (derived). Дочерний/подкласс.
	int y = 20;
};

struct Container {
	Base b; // Композиция: взяли один объект и над ним надстроили новый.
	int y = 20;
	int &x = b.x;
};
```
**Base** - 4 байта (один ``int``)
**Derived** - 8 байтов (два ``int``)
Размер **Container** 24 байта (``int`` + ``int`` + ссылка + выравнивание) из-за использования ссылки:
```c++
int &x = b.x
```
Без ссылки было бы 8 байтов.

---
Изначально есть:
```c++
struct Base { // Базовый класс (base) в C++. Родительский/предок/надкласс/суперкласс (Python, Java).
	int x = 10;
	void foo() const {
		std::cout << "x=" << x << "\n";
	}
};

struct Derived : Base { // Производный класс (derived). Дочерний/подкласс.

	int y = 20;
	void bar() const {
		foo();
		std::cout << "y=" << y << "\n";
	}
};
```
Можно привязывать ссылку на базовый класс к объекту производного класса (так как внутри производного класса лежит кусочек базового), операция бесплатная.

```c++
Derived d;
Base &b = d; //basecast или upcast

//можно выводить методы и значения, а также менять поля
b.foo();
std::cout << "b.x=" << b.x << "\n";
b.x++;

//но функции bar уже нет
b.bar(); //так не скомпилируется
```

Аналогично работают указатели

```c++
Derived d;
Derived *dptr = &d;
Base *bptr = dptr;

//можно вызывать методы
bptr->foo(); 
bptr->bar(); //но так опять не скомпилируется

//можно обращаться к полям
std::cout << "b.x=" << bptr->x << "\n"; //выведет 10
bptr->x++;
std::cout << "d.x=" << d.x << "\n"; //выведет 11

//данные указатели указывают на одно и то же место в памяти
std::cout << dptr << " " << bptr << "\n";
```

Если создаем функцию, где аргументом является ссылка на базовый класс:
```c++
void foo(const Base &b) {
	const Derived &d = static_cast<const Derived&>(b); // derivedcast
}
```
То при передаче в аргумент объект производного класса, ссылка привяжется корректно:
```c++
Derived d;
foo(d); // Not UB: d is really Derived.
```

Однако если убрать ссылку (то есть оставить аргумент по значению), будет ``slicing``
```c++
void bar(Base b) { // Slicing.
	const Derived &d = static_cast<const Derived&>(b);
	//UB, так как теперь b - отдельно живущий объект
	std::cout << ".y=" << d.y << "\n"; // Always UB
	&d.y; // UB
}
int main() {
	Derived d;
	bar(d); // Always UB.
}
```
Отличие двух данных примеров в том, что в первом случае мы знаем, что ``b`` - это **Derived** (так как передается по ссылке), а во втором случае нет.
Если вызвать так:
```c++
Base b;
foo(b); // UB!
bar(b); // Always UB.
```
то оба ``static_cast`` будут UB.

---
### `public`/`private`/`protected`  для методов/полей/наследования
В таком случае, вызовется ``foo`` из **Derived**
```c++
struct Base {
	void foo() {}
};

struct Derived : Base {
	void foo() {}
}
};
int main() {
	Derived d;
	d.foo();
}
```

**Protected** означает, что данный метод может вызывать сам класс, либо его наследники:
```c++
struct Base {
private:
	void foo() {}
protected:
	void bar() {}
public:
	void baz() {}
};

struct Derived : Base {
	void der() {
		foo(); //вызвать foo нельзя (ошибка при компиляции)
		bar(); //но может вызвать bar, так как protected
		baz(); //также может вызвать (public)
	}
};

int main() {
	Derived d;
	d.foo(); //из main нельзя вызвать foo
	d.bar(); //а также нельзя вызвать bar (так как main( не связан ни с Base, ни с Derived
	d.baz(); //публичный метод можно вызвать
}
```
Это позволяет создать у класса 2 интерфейса: публичный и для наследников.

Есть некоторые тонкости с вызовом ``protected`` методов. 
Если у нас есть некоторая структура с ``protected`` методом, то из наследника мы можем вызвать данный метод, однако напрямую ``protected`` методы вызывать нельзя.
```c++
struct Base {
protected:
	void foo() {}
};

struct Derived : Base {
	void bar() {
		foo(); //OK
		this->foo(); // OK
		
		Derived &d = *this; //OK
		d.foo();
		
		Base &b = *this; 
		b.foo(); //не ОК
		
		Base b2;
		b2.foo(); //не ОК
	}
};
То есть если мы используем указатель или ссылку на базовый класс, даже внутри наследника, право на ``protected`` не появляется.

```
---
Наследование тоже может быть ``public`` (по умолчанию для структур), ``protected`` и ``private`` (по умолчанию для классов).
```c++
struct Base {
	void foo() {}
};

struct Derived1 : public Base {}; // По умолчанию для struct Derived1; обычно используется оно.
struct Derived2 : protected Base {};
struct Derived3 : private Base {}; // По умолчанию для class Derived 3.
```
Это влияет на доступность методов из базового класса:
```c++
int main() {
	Derived1 d1;
	Derived2 d2;
	Derived3 d3;
	d1.foo(); //так можно 
	d2.foo(); //а так нельзя, так как наследование protected
	d2.Base::foo(); //так тоже нельзя, так как нельзя конвертировать Derived2 в Base, если я не наследник Derived2
```
Соответственно при ``protected`` наследовании нельзя создать ссылку не в наследнике (то есть в main):
```c++
const Base &b1 = d1; //так можно
const Base &b2 = d2; //а так нет
```

Пример, когда нужно приватное наследование: есть структура, и не хотим, чтобы она была копируемой (делать это с помощью ``protected`` наследования уменьшает код). Стратегия: создаем базовую структуру, в которой запрещаем копирование, и от нее наследуем нашу структуру.
```c++
struct noncopyable { // boost::noncopyable
	noncopyable(const noncopyable&) = delete;
	noncopyable(noncopyable&&) = delete;
	noncopyable &operator=(const noncopyable&) = delete;
	noncopyable &operator=(noncopyable&&) = delete;
};
struct Foo : private noncopyable {
};
```
``private`` нужен, чтобы мы не могли конвертировать ``Foo`` в ``noncopyable``.

То есть приватное наследование гарантирует, что мы не сможем использовать из наследника, который приватным образом наследует базовый класс, даже публичные методы из базового класса:
```c++
class Base {
public:
	void foo() {}
	};
class Derived : /* private */ Base { //в class по умолчанию приватное наследование
};
int main() {
	Derived d;
	d.foo(); //не скомпилируется, так как метод foo в main не видно
}
```

---
### `final`  для структур
Здесь будет ``slicing``
```c++
struct Base {
	Base() {}
	protected:
	Base(const Base &) = default;
	Base(Base &&) = default;
	Base &operator=(const Base &) = default;
	Base &operator=(Base &&) = default;
};
struct Derived1 : Base {
	int value = 123;
};
struct Derived2 : Base {
	int value = 456;
};
struct MegaDerived : Derived1 {
	int value = 10000;
}

int main() {
	MegaDerived md1;
	Derived1 d1 = md1;
}
```
Если объявим структуры **Derived1** и **Derived2** как ``final``, от них больше будет нельзя наследоваться:
```c++
struct Base {
	Base() {}
	protected:
	Base(const Base &) = default;
	Base(Base &&) = default;
	Base &operator=(const Base &) = default;
	Base &operator=(Base &&) = default;
};
struct Derived1 final : Base {
	int value = 123;
};
struct Derived2 final : Base {
	int value = 456;
};
```
---
-  Отличия от оператора конвертации к ссылке

В чем отличия между наследованием и такой конструкцией? 
```c++
struct Base {
	int x; 
};
 struct Derived {
     Base b; 
	 operator Base&() { return b; }
}; 
int main(){
	Derived d; 
	d.b.x = 10;
	Base &b = d; //нравилось
	b.x = 20; 
}
``` 
В наследовании нам нравилось, что можно конвертировать объект к ссылке на родителя. То же можно проэмулировать с помощью оператора неявной конвертации.
Пропадают: виртуальные функции (но можно пытаться их реализовывать как-то по-другому), совместимость по указателям (конвертации по указателям не можем перегрузить, заложены в язык, но если достаточно конвертации по ссылкам, то, может, нам это подходит), красивый доступ к ’x’.
А еще пропадают шаблоны:
```c++
template<typename T>
	struct Base { 
		int x; 
};

 template<typename T>
 struct Derived1 : Base<T> {};

 template<typename T>
 struct Derived2 { 
	 Base<T> b;
	 operator Base<T>&() { return b; } 
};

template<typename T>  
void foo(Base<T> &){}  
//с подстановкой int компилятор справится

int main(){
	Derived1<int> d1;
	food(d1); 
	Derived2<int> d2; foo(d2); //no foo<int>(d2); //yes
}
```
В таком случае можно использовать автовывод от T – компилятор справляется. Но если делаем ”ядерный костыль” с оператором конвертации – уже ошибка компиляции: ”не удалось вывести аргумент T функции foo''. Можно указать тип T явно – тогда ок (компилятор понимает, что ожидается Base от int, находит оператор приведения типа).

---
- (Чисто) виртуальные функции,  `override`/`final`, виртуальный деструктор, таблица виртуальных функций, вызовы в конструкторах и деструкторах

### (Чисто) виртуальные функции

```c++
struct Base {
	virtual void foo() {
	std::cout << "Base::foo()\n";
}
};

struct Derived : Base {
	void foo() override /* C++11 */ { // override: добавить virtual, проверить, что в родителе virtual есть.
	// На самом деле virtual добавляется автоматически, если был в родителе.
	std::cout << "Derived::foo()\n";
	}
};
int main() {
	Base b;
	Derived d;
	b.foo(); //здесь вызовется foo из Base
	d.foo(); //здесь вызовется foo из Derived
	Base &db = d;
	db.foo(); //вызовется Derived, без virtual вызвалось бы Base

}
```
Если есть какой-то класс, в котором есть чисто виртуальный метод (то есть у метода нет реализации, ее должен предоставить кто-то из наследников), то он называется абстрактный (такой класс обычно не используется сам по себе). Если метод чисто виртуальный, то не перезаписать его (**Override**) не страшно (ошибки компиляции не будет), однако если не сделать реализацию в наследнике, то наследник тоже станет абстрактным классом
```c++
struct Base {
	virtual void foo() const = 0; // Base::foo() - чисто виртуальный метод.
};
struct Derived : Base {
	// void foo() override {}
	// Так как foo() нет, то Derived::foo() - чисто виртуальный метод.
	// Следствие: Derived - "абстрактный класс".
};
void foo(const Base &b) {
	b.foo();
}
int main() {
	Derived d; // Запрещено создавать абстрактные классы.
	foo(d);
}
```
В этом случае объект **Derived** можно создавать:
```c++
struct Base {
	virtual void foo() const = 0; // Base::foo() - чисто виртуальный метод.
};

struct Derived : Base {
	void foo() const override {}
	// Derived::foo() - обычный виртуальный метод.
	// Derived - обычный класс, не абстрактный.
};

// void bar(Base b) { // Запрещено создавать объекты типа "абстрактный класс".
// }

int main() {
	Derived d;
	foo(d);
}
```
---
Чисто виртуальные методы нельзя вызывать напрямую из базового класса:
```c++
#include <iostream>

struct Base {
    virtual void foo() = 0;
};

struct Derived : Base {
    void foo() override {
        Base::foo();  // Link error.
        std::cout << "Derived\n";
    }
};

int main() {
    Derived d;
    d.foo();

    d.Base::foo();  // Link error.
}
```

Разница между вызовами виртуальных функций:
```c++
struct Base {
    virtual void foo() {
        std::cout << "Base\n";
    }
};

struct Derived : Base {
    void foo() override {
        Base::foo();  // Отключили виртуальность.
        std::cout << "Derived\n";
    }
};

int main() {
    Derived d;
    d.foo();

    d.Base::foo();  // Отключили виртуальность.

    Base &b = d;
    b.foo();  // Виртуальный вызов.
    b.Base::foo();  // Невиртуальный вызов. Всегда.
}

```
Приватные методы также можно перезаписывать:
```c++
struct Base {
private:
    virtual void foo() {}  // Пример: printTo()

protected:
    virtual void bar() {}

public:
    virtual void baz() {}
};

struct Derived : Base {
    void foo() override {}
    void bar() override {}
    void baz() override {}

    void der() {
        // foo();
        bar();
        baz();
    }
};

int main() {
    Derived d;
    // d.foo();
    // d.bar();
    d.baz();
}
```
---

Виртуальные методы можно сделать ``final``, чтобы в наследнике наследника его 
переопределить не получилось:
```c++
struct Base {
    virtual void foo() = 0;
};

struct Derived : Base {
    void foo() override final {
    }
};

struct MegaDerived : Derived {
    void foo() override { //здесь ошибка
    }
};

``` 

---
### Виртуальный деструктор
Проблема: в данном случае вызывается деструктор от **Human**, а нужно вызывать деструктор от **Student**
```c++
struct Human {
	std::string first_name, last_name; // Possibly wrong.
	Human(std::string first_name_, std::string last_name_)
	: first_name(std::move(first_name_)), last_name(std::move(last_name_)) {
}
};

struct Student : Human {
	std::string group; // Possibly wrong.
	Student(std::string first_name_, std::string last_name_, std::string group_)
		: Human(std::move(first_name_), std::move(last_name_))
		, group(std::move(group_)) {}
};

int main() {
	Human *h = new Student("Egor", "Suvorov", "MBD191");
	delete h; // UB: ~Human()
	// delete static_cast<Student*>(h); // Would be OK.
}
```
Решение: виртуальный деструктор. Теперь во всех производных классах деструкторы автоматически становятся виртуальными
```c++
virtual ~Human() = default;
```
---
### Таблица виртуальных функций
Структуры с виртуальным методами хранят указатель на таблицу виртуальных функций, чтобы можно было найти там необходимый метод и вызвать его. В каждой табличке хранятся указатели на функции.
Если класс использует виртуальные методы, компилятор создает таблицу виртуальных функций (это статический массив). 
Это реализовано примерно так:
```c++
struct Base;  
struct BaseVtable {  
    void (*bar_int_impl)(const Base*, int);  
    void (*bar_string_impl)(const Base*, std::string);  
};  
  
struct Base {   
  const BaseVtable *vtable = &BASE_VTABLE;  
    void foo(int) const {}  
    void foo(std::string) const {}    
    void bar(int arg) const { vtable->bar_int_impl(this, arg); }  
    void bar(std::string arg) const { vtable->bar_string_impl(this, arg); }  
  
private:  
    static void base_bar_int_impl(const Base *b, int) {  
        std::cout << "Base::bar(int)\n";  
    }  
  
    static void base_bar_string_impl(const Base *b, std::string) {  
    }  
  
    static inline const BaseVtable BASE_VTABLE{base_bar_int_impl, base_bar_string_impl};  
};  
  
// На самом деле: struct DerivedVtable : BaseVtable, чтобы можно было добавлять новые виртуальные методы.  
struct Derived : Base {  
    Derived() {  
        vtable = &DERIVED_VTABLE;  
    }  
  
private:  
    static void derived_bar_int_impl(const Base *b, int) {  
        std::cout << "Derived::bar(int)\n";  
    }  
    static void derived_bar_string_impl(const Base *b, std::string) {  
    }  
  
    static inline const BaseVtable DERIVED_VTABLE{derived_bar_int_impl, derived_bar_string_impl};  
};  
  
void f(const Base &b) {  
    b.bar(10);  
    b.bar("str");  
}  
  
int main() {  
    Derived d;  
    f(d);
}
```
---
### Вызовы в конструкторах и деструкторах

Пусть у базового класса есть виртуальная функция, и эту функцию мы вызываем
в конструкторе (или в деструкторе), плюс есть другая ее версия в наследнике.
В таком случае вызывается функция, которая определена в базовом классе, так как
сначала вызывается конструктор базового класса, потом инициализируются поля,
и только после этого можно вызывать собственные функции:
```c++
struct Base {
    int value = 123;

    virtual void foo() {
        std::cout << "foo(" << value << ")\n";
    };

    Base() {
        foo();
    }

    ~Base() {
        foo();
    }
};

struct Derived : Base {
    int value2 = 456;

    Derived() : Base(), value2(100) {}

    void foo() override {
        std::cout << "foo(" << value << ", " << value2 << ")\n";
    }
};

int main() {
    Derived d; 
}
```
В примере выше вывод будет таким:
```
foo(123)
foo(123)
```
В деструкторе тоже будет вызван метод ``foo``, определенный в ``Base``, так
как деструкторы вызываются в обратном порядке.

В случае чисто виртуальных методов такой код не скомпилируется:
```c++
struct Base {
    int value = 123;

    virtual void printTo() = 0;

    Base() {
        printTo();
    }
};

struct Derived : Base {
    void printTo() override {
    }
};

int main() {
    Derived d;
}
```

---

-   `dynamic_cast`  для указателей и ссылок, if-init-statement
### `dynamic_cast`  для указателей и ссылок
`dynamic_cast` нужна, чтобы проверить верно ли, что какой-то объект данного типа работает с указателями (с ссылками он похож на `static_cast`, так как предполагает, что конвертация всегда успешная, иначе вызывает ошибку компиляции). В случае с указателями `dynamic_cast` возвращает либо ``nullptr``, если конвертация прошла неуспешно, в другой случае возвращает указатель.
`dynamic_cast` работает только если Base "полиморфный".
```c++
struct Base {  
    virtual void foo() {};  
};  
  
struct Derived1 : Base {  
//    void foo() override {}  
};  
  
void f(const Base &b) {  
    // dynamic_cast работает только если Base "полиморфный".  
    // Класс "полиморфный" <=> есть хотя бы одна виртуальная функция (обычно есть виртуальный деструктор).  
	 const Derived1 *d1 = dynamic_cast<const Derived1*>(&b);
	 if (d1) {
		 std::cout << "Derived1\n";
	 }
}
```
Почему ``dynamic_cast`` работает только если Base "полиморфный": если класс полиморфный, то у него есть виртуальная функция, то есть создается таблица виртуальных функций, и в ней мы можем сравнить указатели.

---
### if-init-statement
Чтобы сократить код из предыдущего примера, можно использовать **if-init-statement**. Он работает не только с ``dynamic_cast``, однако с ним - это наиболее популярный пример:
```c++
if (const Derived1 *d1 = dynamic_cast<const Derived1*>(&b); d1) {
	std::cout << "Derived1\n";
	// d1 видно
}
// d1 не видно
```
Здесь мы создаем переменную внутри конструкции ``if``, после ``;`` - это условие ``if`` с какой-то переменной.
Вся эта конструкция (``dynamic_cast`` и **if-init-statement**) нужна, если мы руками хотим проверить некоторое множество наследников.

---
-   Hiding и изменение видимости полей/методов

Если у нас есть какой-то базовый класс и его наследник, а также 2 функции ``foo`` - в базовом она принимает, например, ``int``, а в наследнике ``double``, то в таком случае:
```c++
struct Foo {
	void foo(int) { std::cout << "int\n"; }
};
struct Bar : Foo {
	void foo(double) { std::cout << "double\n"; }
};
int main() {
	Foo f;
	f.foo(1); // int
	f.foo(1.2); // int
}
```
даже если мы передадим ``foo`` типа ``double``,  то вызовется все равно метод структуры ``Foo`` (если мы вызываем от объекта типа ``Foo``). 
Если мы сделаем так:
```c++
Bar b;
b.foo(1.2); // double
b.foo(1); // double :(
```
То в обоих случаях вызовется метод структуры ``Bar``. Здесь действует правило: если объявлен метод с именем foo() в наследнике, то смотри на перегрузки только из наследника. А родительский метод "скрой" (**hide**).
Если возьмем ссылку ``Foo`` на объект типа ``Bar``, то в обоих случаях вызовется метод структуры ``Bar``:
```c++
Foo &f2 = b;
f2.foo(1); // int
f2.foo(1.2); // int
```
Если мы хотим, чтобы были перегрузки из ``Foo`` и ``Bar``, то рядом с методом в структуре ``Bar`` можно написать ``using``:
```c++
struct Bar : Foo {
	using Foo::foo;
	void foo(double) { std::cout << "double\n"; }
};
```
Теперь он будет перегружаться как обычно.

``using`` также можно использовать, чтобы вызывать ``protected`` методы, например, из main (но так делать лучше не стоит):
```c++
struct Foo {  
protected:  
    void magic() {}  
};  
  
struct Bar : Foo {  
    using Foo::magic;  
};  
  
int main() {  
    Bar b;  
    b.magic();  
}
```
Или можно наоборот сузить видимость (сделать ``private``), тогда из наследника мы это достать не сможем:
```c++
struct Foo {  
protected:  
    void magic() {}  
};  
  
struct Bar : Foo {  
private:  //сделали private, поменяли видимость
    using Foo::magic;  
};  
  
struct Baz : Bar {  
    void magic2() {  
        magic();  //вот так не скомпилируется
		Foo::magic();  //а вот так ОК 
    }  
};
```
То есть если мы используем ``using``, можно ненароком сделать методы базовой структуру публичными (даже если они были ``protected``).

---


###  Проблема круга-квадрата и решения(circle-ellipse)
Можно почитать умную статью: [тык](https://isocpp.org/wiki/faq/proper-inheritance)

Рассмотрим такой функционал как get и set:
1) Пусть круг - частный случай эллипса:
```cpp
// OK

struct Circle {

    virtual void setRadius(int r);

};

struct Ellipse : Circle {

    virtual void setRadius(int r); // устанавливает w и h - нет противоречий
    virtual void setWidth(int w);
    virtual void setHeight(int h);

};

// WTF
struct Circle {
    virtual int getRadius();
};

struct Ellipse : Circle {
    virtual int getRadius() { ????????????? } // при различных w и h непонятно что возвращать
    virtual int getWidth();
    virtual int getHeight();
};
```

2) Пусть эллипс - частный случай круга:
```cpp
// OK
struct Ellipse {
    virtual int getWidth();
    virtual int getHeight();
};

struct Circle : Ellipse {
    int getRadius();
};
int getWidth(); //спокойно возвращают просто радиус, если круг
int getHeight();

// WTF

struct Ellipse {
    virtual void setWidth(int w);
    virtual void setHeight(int h);
};

struct Circle : Ellipse {
    virtual void setWidth() { ..... } // можем сделать что устанавливаем w и h радиусом
    void setRadius(int r);
};

//но ломается тест: 
Ellipse &e = ......
e.setWidth(10);
e.setHeight(20);
assert(e.width() == 10);
assert(e.height() == 20);
```

Итоговый вывод: бытовая/математическая логика не работает для программирования и нужно выбирать, что конкретно подходит под вашу программу, либо просто не использовать в данном случае наследование
### Ключевое слово  `mutable`  (`27-210513`)
**mutable** можем сделать таким поле класса и можно будет менять даже в const-qualified методах(когда это данные, которые имеют отношение только к реализации, но не к непосредственному использованию)

- mutex
```cpp
#include <mutex>

struct atomic_int {
int get() const {
   std::unique_lock l(m);
   return value;
}

void set(int new_value) {
    std::unique_lock l(m);
    value = new_value;

}
private:

mutable std::mutex m; 
int value;

};
```

- про матрицы
(чтобы каждый раз не считать по очень долго определитель, а кешировать значение -> ускорение)

```cpp
struct matrix {

int determinant() const {
  //первый раз считаем за куб, в остальных случаях берем уже вычисленное
}

private:
int n;
std::vector<int> data;
mutable std::optional<int> last_determinant;

};
```

### Использование  `const_cast`  для упрощения реализации (`30-210603`)
 - Для совместимости со старым кодом, чтобы отбрасывать const
 ```cpp
 void old_c_print_line(char *str) {
   printf("%s\n", str);
}

old_c_print_line(const_cast<char *>("hello"));
 ```
  - Для сокращения кода, чтобы выражать функции, реализовав самую строгую из них, а все остальные выразить через нее отбрасывая const
  ```cpp
T &get() & {
    return const_cast<T &>(std::as_const(*this).get());
}

T &&get() && {
    return std::move(get());
}

const T &get() const & { //основная реализация
    assert(initialized);
    return data;
}

// Incorrect implementation: поскольку 
/*
T& get() {
assert(initialized);
return data;
}
const T &get() const {
return const_cast<optional*>(this)->get();
}
*/
  ```
  
  > Казалось бы, при чем здесь наследование


### RTTI,  `typeid`,  `type_info`,  `boost::core::demangle`
**Run-Time-Type-Information** - информация, которую компилятор добавляет в бинарник для работы `dinamic_cast`, `typeid`, `type_info`. (Виртуальное наследование и виртуальные функции - отдельный механизм)
Можно отключить для сохранения места, если в программе этим не пользуемся. 
Для этого флаг: `-fno-rtti` , есть замены, `Boost::TypeIndex`

```cpp

#include <typeinfo>
#include <vector>
#include <boost/core/demangle.hpp> //красивая библиотека, которая умеет расшифровывать type_id в человечески-читаемый вид

// Важно, что Base полиморфный (есть хотя бы один виртуальный метод), иначе не включится RTTI.

// Тогда typeid() будет работать на этапе компиляции.

struct Base { virtual ~Base() {} };

struct Derived : Base {};

int foo() {
    std::cout << "foo()\n";
    return 10;
}

int main() {
    Base b;
    Derived d;

// RTTI: Run-Time Type Information.
// 1 - typeid(тип)
    const std::type_info &info_base = typeid(Base);
    const std::type_info &info_derived = typeid(Derived);
    const std::type_info &info_int = typeid(int);

// 2 - typeid(выражение)
    const std::type_info &info_int_expr = typeid(2 + 2 + foo()); // foo() не вызывается и само выражение не вычисляется
// 3
    const std::type_info &info_b = typeid(b);
    const std::type_info &info_d = typeid(d);
    std::cout << (info_base == info_b) << "\n";
    std::cout << (info_base == info_d) << "\n";
// std::type_index можно класть в set
    std::cout << info_int_expr.name() << "\n";
    std::cout << info_b.name() << "\n";
    std::cout << typeid(std::vector<int>).name() << "\n"; //выводит в каком-то страшном нечитабельном виде
    std::cout << boost::core::demangle(info_int_expr.name()) << "\n";
    std::cout << boost::core::demangle(info_b.name()) << "\n";
    std::cout << boost::core::demangle(typeid(std::vector<int>).name()) << "\n"; //умеет парсить красивее, но без гарантий

}
```

###  `initializer_list`, в том числе при рекурсивном list initialisation
Специальный тип, чтобы его писать в конструкторах единственным параметром

НО ! Все элементы константные -> нельзя мувать -> только копировать 

#### Пример кода: 
```cpp
struct Bar {

    Bar(std::initializer_list<int> x) {
        std::cout << x.size() << " " << *x.begin() << "\n";
    } //есть size и итератор

    Bar(std::initializer_list<Foo> x) {
        std::cout << x.size() << " " << x.begin()->val << "\n";
    }

    Bar([[maybe_unused]] std::initializer_list<std::unique_ptr<int>> x) {
// std::unique_ptr<int> y = std::move(*x.begin()); // Oops :( не можем так сделать из-за const
    }
};
```
Сделать дерево рекурсивной инициализации, где структура инициализируется либо от значения, либо от initializer_list. И сохраняем все в один вектор. 

#### Пример кода
```cpp
struct Baz {

    int val;

    std::vector<Baz> children;

    Baz(int val_) : val(val_) {
    }

    Baz(std::initializer_list<Baz> children_)
            : val(-1), children(children_.begin(), children_.end()) {
    }

    void print() const {
        if (val >= 0) {
            assert(children.empty());
            std::cout << val;
        } else {
            std::cout << "{";
            for (const auto &c : children)
                c.print();
            std::cout << "}";
        }
    }
};


Baz{
1, //
2, //
{3, 4}, //
{{5}}, //
{{6}, 7, {}}, //
8 //
}
.print();
```
Вывод .print(): {12{34}{{5}}{{6}7{}}8}
