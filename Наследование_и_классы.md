## Наследование и классы

-   Совместимость ссылок и указателей,  `public`/`private`/`protected`  для методов/полей/наследования,  `final`  для структур

### Совместимость ссылок и указателе
```c++
struct Base { // Базовый класс (base) в C++. Родительский/предок/надкласс/суперкласс (Python, Java).
	int x = 10;
};

struct Derived : Base { // Производный класс (derived). Дочерний/подкласс.
	int y = 20;
};

struct Container {
	Base b; // Композиция: взяли один объект и над ним надстроили новый.
	int y = 20;
	int &x = b.x;
};
```
**Base** - 4 байта (один ``int``)
**Derived** - 8 байтов (два ``int``)
Размер **Container** 16 байтов (``int`` + ``int`` + ссылка + выравнивание) из-за использования ссылки:
```c++
int &x = b.x
```
Без ссылки было бы 8 байтов.

---
Изначально есть:
```c++
struct Base { // Базовый класс (base) в C++. Родительский/предок/надкласс/суперкласс (Python, Java).
	int x = 10;
	void foo() const {
		std::cout << "x=" << x << "\n";
	}
};

struct Derived : Base { // Производный класс (derived). Дочерний/подкласс.

	int y = 20;
	void bar() const {
		foo();
		std::cout << "y=" << y << "\n";
	}
};
```
Можно привязывать ссылку на базовый класс к объекту производного класса (так как внутри производного класса лежит кусочек базового), операция бесплатная.

```c++
Derived d;
Base &b = d; //basecast или upcast

//можно выводить методы и значения, а также менять поля
b.foo();
std::cout << "b.x=" << b.x << "\n";
b.x++;

//но функции bar уже нет
b.bar(); //так не скомпилируется
```

Аналогично работают указатели

```c++
Derived d;
Derived *dptr = &d;
Base *bptr = dptr;

//можно вызывать методы
bptr->foo(); 
bptr->bar(); //но так опять не скомпилируется

//можно обращаться к полям
std::cout << "b.x=" << bptr->x << "\n"; //выведет 10
bptr->x++;
std::cout << "d.x=" << d.x << "\n"; //выведет 11

//данные указатели указывают на одно и то же место в памяти
std::cout << dptr << " " << bptr << "\n";
```

Если создаем функцию, где аргументом является ссылка на базовый класс:
```c++
void foo(const Base &b) {
	const Derived &d = static_cast<const Derived&>(b); // derivedcast
}
```
То при передаче в аргумент объект производного класса, ссылка привяжется корректно:
```c++
Derived d;
foo(d); // Not UB: d is really Derived.
```

Однако если убрать ссылку (то есть оставить аргумент по значению), будет ``slicing``
```c++
void bar(Base b) { // Slicing.
	const Derived &d = static_cast<const Derived&>(b);
	//UB, так как теперь b - отдельно живущий объект
	std::cout << ".y=" << d.y << "\n"; // Always UB
	&d.y; // UB
}
int main() {
	Derived d;
	bar(d); // Always UB.
}
```
Отличие двух данных примеров в том, что в первом случае мы знаем, что ``b`` - это **Derived** (так как передается по ссылке), а во втором случае нет.
Если вызвать так:
```c++
Base b;
foo(b); // UB!
bar(b); // Always UB.
```
то оба ``static_cast`` будут UB.

---
### `public`/`private`/`protected`  для методов/полей/наследования
В таком случае, вызовется ``foo`` из **Derived**
```c++
struct Base {
	void foo() {}
};

struct Derived : Base {
	void foo() {}
}
};
int main() {
	Derived d;
	d.foo();
}
```

**Protected** означает, что данный метод может вызывать сам класс, либо его наследники:
```c++
struct Base {
private:
	void foo() {}
protected:
	void bar() {}
public:
	void baz() {}
};

struct Derived : Base {
	void der() {
		foo(); //вызвать foo нельзя (ошибка при компиляции)
		bar(); //но может вызвать bar, так как protected
		baz(); //также может вызвать (public)
	}
};

int main() {
	Derived d;
	d.foo(); //из main нельзя вызвать foo
	d.bar(); //а также нельзя вызвать bar (так как main( не связан ни с Base, ни с Derived
	d.baz(); //публичный метод можно вызвать
}
```
Это позволяет создать у класса 2 интерфейса: публичный и для наследников.

Есть некоторые тонкости с вызовом ``protected`` методов. 
Если у нас есть некоторая структура с ``protected`` методом, то из наследника мы можем вызвать данный метод, однако напрямую ``protected`` методы вызывать нельзя.
```c++
struct Base {
protected:
	void foo() {}
};

struct Derived : Base {
	void bar() {
		foo(); //OK
		this->foo(); // OK
		
		Derived &d = *this; //OK
		d.foo();
		
		Base &b = *this; 
		b.foo(); //не ОК
		
		Base b2;
		b2.foo(); //не ОК
	}
};
То есть если мы используем указатель или ссылку на базовый класс, даже внутри наследника, право на ``protected`` не появляется.

```
---
Наследование тоже может быть ``public`` (по умолчанию для структур), ``protected`` и ``private`` (по умолчанию для классов).
```c++
struct Base {
	void foo() {}
};

struct Derived1 : public Base {}; // По умолчанию для struct Derived1; обычно используется оно.
struct Derived2 : protected Base {};
struct Derived3 : private Base {}; // По умолчанию для class Derived 3.
```
Это влияет на доступность методов из базового класса:
```c++
int main() {
	Derived1 d1;
	Derived2 d2;
	Derived3 d3;
	d1.foo(); //так можно 
	d2.foo(); //а так нельзя, так как наследование protected
	d2.Base::foo(); //так тоже нельзя, так как нельзя конвертировать Derived2 в Base, если я не наследник Derived2
```
Соответственно при ``protected`` наследовании нельзя создать ссылку не в наследнике (то есть в main):
```c++
const Base &b1 = d1; //так можно
const Base &b2 = d2; //а так нет
```

Пример, когда нужно приватное наследование: есть структура, и не хотим, чтобы она была копируемой (делать это с помощью ``protected`` наследования уменьшает код). Стратегия: создаем базовую структуру, в которой запрещаем копирование, и от нее наследуем нашу структуру.
```c++
struct noncopyable { // boost::noncopyable
	noncopyable(const noncopyable&) = delete;
	noncopyable(noncopyable&&) = delete;
	noncopyable &operator=(const noncopyable&) = delete;
	noncopyable &operator=(noncopyable&&) = delete;
};
struct Foo : private noncopyable {
};
```
``private`` нужен, чтобы мы не могли конвертировать ``Foo`` в ``noncopyable``.

То есть приватное наследование гарантирует, что мы не сможем использовать из наследника, который приватным образом наследует базовый класс, даже публичные методы из базового класса:
```c++
class Base {
public:
	void foo() {}
	};
class Derived : /* private */ Base { //в class по умолчанию приватное наследование
};
int main() {
	Derived d;
	d.foo(); //не скомпилируется, так как метод foo в main не видно
}
```

---
### `final`  для структур
Здесь будет ``slicing``
```c++
struct Base {
	Base() {}
	protected:
	Base(const Base &) = default;
	Base(Base &&) = default;
	Base &operator=(const Base &) = default;
	Base &operator=(Base &&) = default;
};
struct Derived1 : Base {
	int value = 123;
};
struct Derived2 : Base {
	int value = 456;
};
struct MegaDerived : Derived1 {
	int value = 10000;
}

int main() {
	MegaDerived md1;
	Derived1 d1 = md1;
}
```
Если объявим структуры **Derived1** и **Derived2** как ``final``, от них больше будет нельзя наследоваться:
```c++
struct Base {
	Base() {}
	protected:
	Base(const Base &) = default;
	Base(Base &&) = default;
	Base &operator=(const Base &) = default;
	Base &operator=(Base &&) = default;
};
struct Derived1 final : Base {
	int value = 123;
};
struct Derived2 final : Base {
	int value = 456;
};
```
---
-  Отличия от оператора конвертации к ссылке

В чем отличия между наследованием и такой конструкцией? 
```c++
struct Base {
	int x; 
};
 struct Derived {
     Base b; 
	 operator Base&() { return b; }
}; 
int main(){
	Derived d; 
	d.b.x = 10;
	Base &b = d; //нравилось
	b.x = 20; 
}
``` 
В наследовании нам нравилось, что можно конвертировать объект к ссылке на родителя. То же можно проэмулировать с помощью оператора неявной конвертации.
Пропадают: виртуальные функции (но можно пытаться их реализовывать как-то по-другому), совместимость по указателям (конвертации по указателям не можем перегрузить, заложены в язык, но если достаточно конвертации по ссылкам, то, может, нам это подходит), красивый доступ к ’x’.
А еще пропадают шаблоны:
```c++
template<typename T>
	struct Base { 
		int x; 
};

 template<typename T>
 struct Derived1 : Base<T> {};

 template<typename T>
 struct Derived2 { 
	 Base<T> b;
	 operator Base<T>&() { return b; } 
};

template<typename T>  
void foo(Base<T> &){}  
//с подстановкой int компилятор справится

int main(){
	Derived1<int> d1;
	food(d1); 
	Derived2<int> d2; foo(d2); //no foo<int>(d2); //yes
}
```
В таком случае можно использовать автовывод от T – компилятор справляется. Но если делаем ”ядерный костыль” с оператором конвертации – уже ошибка компиляции: ”не удалось вывести аргумент T функции foo''. Можно указать тип T явно – тогда ок (компилятор понимает, что ожидается Base от int, находит оператор приведения типа).

---
- (Чисто) виртуальные функции,  `override`/`final`, виртуальный деструктор, таблица виртуальных функций, вызовы в конструкторах и деструкторах

### (Чисто) виртуальные функции

```c++
struct Base {
	virtual void foo() {
	std::cout << "Base::foo()\n";
}
};

struct Derived : Base {
	void foo() override /* C++11 */ { // override: добавить virtual, проверить, что в родителе virtual есть.
	// На самом деле virtual добавляется автоматически, если был в родителе.
	std::cout << "Derived::foo()\n";
	}
};
int main() {
	Base b;
	Derived d;
	b.foo(); //здесь вызовется foo из Base
	d.foo(); //здесь вызовется foo из Derived
	Base &db = d;
	db.foo(); //вызовется Derived, без virtual вызвалось бы Base

}
```
Если есть какой-то класс, в котором есть чисто виртуальный метод (то есть у метода нет реализации, ее должен предоставить кто-то из наследников), то он называется абстрактный (такой класс обычно не используется сам по себе). Если метод чисто виртуальный, то не перезаписать его (**Override**) не страшно (ошибки компиляции не будет), однако если не сделать реализацию в наследнике, то наследник тоже станет абстрактным классом
```c++
struct Base {
	virtual void foo() const = 0; // Base::foo() - чисто виртуальный метод.
};
struct Derived : Base {
	// void foo() override {}
	// Так как foo() нет, то Derived::foo() - чисто виртуальный метод.
	// Следствие: Derived - "абстрактный класс".
};
void foo(const Base &b) {
	b.foo();
}
int main() {
	Derived d; // Запрещено создавать абстрактные классы.
	foo(d);
}
```
В этом случае объект **Derived** можно создавать:
```c++
struct Base {
	virtual void foo() const = 0; // Base::foo() - чисто виртуальный метод.
};

struct Derived : Base {
	void foo() const override {}
	// Derived::foo() - обычный виртуальный метод.
	// Derived - обычный класс, не абстрактный.
};

// void bar(Base b) { // Запрещено создавать объекты типа "абстрактный класс".
// }

int main() {
	Derived d;
	foo(d);
}
```
---
Чисто виртуальные методы нельзя вызывать напрямую из базового класса:
```c++
#include <iostream>

struct Base {
    virtual void foo() = 0;
};

struct Derived : Base {
    void foo() override {
        Base::foo();  // Link error.
        std::cout << "Derived\n";
    }
};

int main() {
    Derived d;
    d.foo();

    d.Base::foo();  // Link error.
}
```

Разница между вызовами виртуальных функций:
```c++
struct Base {
    virtual void foo() {
        std::cout << "Base\n";
    }
};

struct Derived : Base {
    void foo() override {
        Base::foo();  // Отключили виртуальность.
        std::cout << "Derived\n";
    }
};

int main() {
    Derived d;
    d.foo();

    d.Base::foo();  // Отключили виртуальность.

    Base &b = d;
    b.foo();  // Виртуальный вызов.
    b.Base::foo();  // Невиртуальный вызов. Всегда.
}

```
Приватные методы также можно перезаписывать:
```c++
struct Base {
private:
    virtual void foo() {}  // Пример: printTo()

protected:
    virtual void bar() {}

public:
    virtual void baz() {}
};

struct Derived : Base {
    void foo() override {}
    void bar() override {}
    void baz() override {}

    void der() {
        // foo();
        bar();
        baz();
    }
};

int main() {
    Derived d;
    // d.foo();
    // d.bar();
    d.baz();
}
```
---

Виртуальные методы можно сделать ``final``, чтобы в наследнике наследника его 
переопределить не получилось:
```c++
struct Base {
    virtual void foo() = 0;
};

struct Derived : Base {
    void foo() override final {
    }
};

struct MegaDerived : Derived {
    void foo() override { //здесь ошибка
    }
};

``` 

---
### Виртуальный деструктор
Проблема: в данном случае вызывается деструктор от **Human**, а нужно вызывать деструктор от **Student**
```c++
struct Human {
	std::string first_name, last_name; // Possibly wrong.
	Human(std::string first_name_, std::string last_name_)
	: first_name(std::move(first_name_)), last_name(std::move(last_name_)) {
}
};

struct Student : Human {
	std::string group; // Possibly wrong.
	Student(std::string first_name_, std::string last_name_, std::string group_)
		: Human(std::move(first_name_), std::move(last_name_))
		, group(std::move(group_)) {}
};

int main() {
	Human *h = new Student("Egor", "Suvorov", "MBD191");
	delete h; // UB: ~Human()
	// delete static_cast<Student*>(h); // Would be OK.
}
```
Решение: виртуальный деструктор. Теперь во всех производных классах деструкторы автоматически становятся виртуальными
```c++
virtual ~Human() = default;
```
---
### Таблица виртуальных функций
Структуры с виртуальным методами хранят указатель на таблицу виртуальных функций, чтобы можно было найти там необходимый метод и вызвать его. В каждой табличке хранятся указатели на функции.
Если класс использует виртуальные методы, компилятор создает таблицу виртуальных функций (это статический массив). 
Это реализовано примерно так:
```c++
struct Base;  
struct BaseVtable {  
    void (*bar_int_impl)(const Base*, int);  
    void (*bar_string_impl)(const Base*, std::string);  
};  
  
struct Base {   
  const BaseVtable *vtable = &BASE_VTABLE;  
    void foo(int) const {}  
    void foo(std::string) const {}    
    void bar(int arg) const { vtable->bar_int_impl(this, arg); }  
    void bar(std::string arg) const { vtable->bar_string_impl(this, arg); }  
  
private:  
    static void base_bar_int_impl(const Base *b, int) {  
        std::cout << "Base::bar(int)\n";  
    }  
  
    static void base_bar_string_impl(const Base *b, std::string) {  
    }  
  
    static inline const BaseVtable BASE_VTABLE{base_bar_int_impl, base_bar_string_impl};  
};  
  
// На самом деле: struct DerivedVtable : BaseVtable, чтобы можно было добавлять новые виртуальные методы.  
struct Derived : Base {  
    Derived() {  
        vtable = &DERIVED_VTABLE;  
    }  
  
private:  
    static void derived_bar_int_impl(const Base *b, int) {  
        std::cout << "Derived::bar(int)\n";  
    }  
    static void derived_bar_string_impl(const Base *b, std::string) {  
    }  
  
    static inline const BaseVtable DERIVED_VTABLE{derived_bar_int_impl, derived_bar_string_impl};  
};  
  
void f(const Base &b) {  
    b.bar(10);  
    b.bar("str");  
}  
  
int main() {  
    Derived d;  
    f(d);
}
```
---
### Вызовы в конструкторах и деструкторах

Пусть у базового класса есть виртуальная функция, и эту функцию мы вызываем
в конструкторе (или в деструкторе), плюс есть другая ее версия в наследнике.
В таком случае вызывается функция, которая определена в базовом классе, так как
сначала вызывается конструктор базового класса, потом инициализируются поля,
и только после этого можно вызывать собственные функции:
```c++
struct Base {
    int value = 123;

    virtual void foo() {
        std::cout << "foo(" << value << ")\n";
    };

    Base() {
        foo();
    }

    ~Base() {
        foo();
    }
};

struct Derived : Base {
    int value2 = 456;

    Derived() : Base(), value2(100) {}

    void foo() override {
        std::cout << "foo(" << value << ", " << value2 << ")\n";
    }
};

int main() {
    Derived d; 
}
```
В примере выше вывод будет таким:
```
foo(123)
foo(123)
```
В деструкторе тоже будет вызван метод ``foo``, определенный в ``Base``, так
как деструкторы вызываются в обратном порядке.

В случае чисто виртуальных методов такой код не скомпилируется:
```c++
struct Base {
    int value = 123;

    virtual void printTo() = 0;

    Base() {
        printTo();
    }
};

struct Derived : Base {
    void printTo() override {
    }
};

int main() {
    Derived d;
}
```

---

-   `dynamic_cast`  для указателей и ссылок, if-init-statement
### `dynamic_cast`  для указателей и ссылок
`dynamic_cast` нужна, чтобы проверить верно ли, что какой-то объект данного типа работает с указателями (с ссылками он похож на `static_cast`, так как предполагает, что конвертация всегда успешная, иначе вызывает ошибку компиляции). В случае с указателями `dynamic_cast` возвращает либо ``nullptr``, если конвертация прошла неуспешно, в другой случае возвращает указатель.
`dynamic_cast` работает только если Base "полиморфный".
```c++
struct Base {  
    virtual void foo() {};  
};  
  
struct Derived1 : Base {  
//    void foo() override {}  
};  
  
void f(const Base &b) {  
    // dynamic_cast работает только если Base "полиморфный".  
    // Класс "полиморфный" <=> есть хотя бы одна виртуальная функция (обычно есть виртуальный деструктор).  
	 const Derived1 *d1 = dynamic_cast<const Derived1*>(&b);
	 if (d1) {
		 std::cout << "Derived1\n";
	 }
}
```
Почему ``dynamic_cast`` работает только если Base "полиморфный": если класс полиморфный, то у него есть виртуальная функция, то есть создается таблица виртуальных функций, и в ней мы можем сравнить указатели.

---
### if-init-statement
Чтобы сократить код из предыдущего примера, можно использовать **if-init-statement**. Он работает не только с ``dynamic_cast``, однако с ним - это наиболее популярный пример:
```c++
if (const Derived1 *d1 = dynamic_cast<const Derived1*>(&b); d1) {
	std::cout << "Derived1\n";
	// d1 видно
}
// d1 не видно
```
Здесь мы создаем переменную внутри конструкции ``if``, после ``;`` - это условие ``if`` с какой-то переменной.
Вся эта конструкция (``dynamic_cast`` и **if-init-statement**) нужна, если мы руками хотим проверить некоторое множество наследников.

---
-   Hiding и изменение видимости полей/методов

Если у нас есть какой-то базовый класс и его наследник, а также 2 функции ``foo`` - в базовом она принимает, например, ``int``, а в наследнике ``double``, то в таком случае:
```c++
struct Foo {
	void foo(int) { std::cout << "int\n"; }
};
struct Bar : Foo {
	void foo(double) { std::cout << "double\n"; }
};
int main() {
	Foo f;
	f.foo(1); // int
	f.foo(1.2); // int
}
```
даже если мы передадим ``foo`` типа ``double``,  то вызовется все равно метод структуры ``Foo`` (если мы вызываем от объекта типа ``Foo``). 
Если мы сделаем так:
```c++
Bar b;
b.foo(1.2); // double
b.foo(1); // double :(
```
То в обоих случаях вызовется метод структуры ``Bar``. Здесь действует правило: если объявлен метод с именем foo() в наследнике, то смотри на перегрузки только из наследника. А родительский метод "скрой" (**hide**).
Если возьмем ссылку ``Foo`` на объект типа ``Bar``, то в обоих случаях вызовется метод структуры ``Bar``:
```c++
Foo &f2 = b;
f2.foo(1); // int
f2.foo(1.2); // int
```
Если мы хотим, чтобы были перегрузки из ``Foo`` и ``Bar``, то рядом с методом в структуре ``Bar`` можно написать ``using``:
```c++
struct Bar : Foo {
	using Foo::foo;
	void foo(double) { std::cout << "double\n"; }
};
```
Теперь он будет перегружаться как обычно.

``using`` также можно использовать, чтобы вызывать ``protected`` методы, например, из main (но так делать лучше не стоит):
```c++
struct Foo {  
protected:  
    void magic() {}  
};  
  
struct Bar : Foo {  
    using Foo::magic;  
};  
  
int main() {  
    Bar b;  
    b.magic();  
}
```
Или можно наоборот сузить видимость (сделать ``private``), тогда из наследника мы это достать не сможем:
```c++
struct Foo {  
protected:  
    void magic() {}  
};  
  
struct Bar : Foo {  
private:  //сделали private, поменяли видимость
    using Foo::magic;  
};  
  
struct Baz : Bar {  
    void magic2() {  
        magic();  //вот так не скомпилируется
		Foo::magic();  //а вот так ОК 
    }  
};
```
То есть если мы используем ``using``, можно ненароком сделать методы базовой структуру публичными (даже если они были ``protected``).

---

###   Конструкторы и наследование: слайсинг, using, виртуальные конструкторы и паттерн "фабричная функция" (в том числе для make_unique)

**Конструкторы**
В списке инициализации можно вызвать конструкторы родителей, если этого не делать, то у родителя должен быть конструктор по умолчанию.
```cpp
struct Base {
    int x;
    Base(int x_) : x(x_) {}
};

struct Derived : Base {
    int y = 20;

    Derived() : Base(10) {}
    // Derived(int y_) : y(y_), Base(10) {}  // -Wreorder (сначала инициализируем родителя)
};

struct DerivedNaive : Base {
};

int main() {
    Derived d;
    // DerivedNaive dn(10);  // Конструкторы не наследуются.
    // operator=, конструкторы копирования/перемещения генерируются заново (если можно).
}
```

Если у Derived нет конструктора, а у Base есть конструктор от одного аргумента, то непонятно как инициализировать Base в строчке 
```cpp
Derived d;
```

**В С++ нет понятия виртуальный конструктор**. Для этих целей используется фабричный метод (далее) и виртуальный метод ``clone()`` (далее).

**Slicing**

Плохой пример:
```cpp
#include <iostream>
#include <vector>

struct Human {
    std::string first_name, last_name;  // Possibly wrong.
};

struct Student : Human {
    std::string group;  // Possibly wrong.
};

int main() {
    std::vector<Human> people;
    std::vector<Student> students;
}
```
Вектор выделяет память для Human, тогда мы не можем добавить Student. Отдельно делать векторы для Human и Student странно, зачем тогда наследование. Фиксится вот так:
```cpp
std::vector<std::unique_ptr<Human>> people;
```
Каждый элемент вектора - указатель на Human и Student, тогда объекты могут иметь разные типы, занимать разное место в памяти, а вектору норм, потому что он знает размер указателя. При удалении вектор вызовет деструктор у умных указателей, а они вызовут удаление у всех объектов. (см. Виртуальный деструктор). Без указателя - слайсинг.

**Еще слайсинг**
Дана растущая вглубь иерархия из полиморфных (имеющих виртуальную функцию) классов.
```cpp
struct Base {
    nonmovable() {}
    virtual ~Base() {}
};

struct Derived1 : Base {
};

struct Derived11 : Derived1 {
};

struct Derived2 : Base {
};
```
Обычно в таких иерархиях полностью запрещают (иначе слайсинг можно избежать с помощью метапрограммирования) операторы/конструкторы копирования/перемещения, т.к. может случиться слайсинг и часть информации потеряется. Например:
```cpp
Derived11 d11;
Derived1 d1c = d11; // slicing
```

*Как запретить?* В базовом классе:
```cpp
struct Base {
    Base() {}
    Base(const Base&) = delete;
    Base(Base &&) = delete;
    Base &operator=(const Base &) = delete;
    Base &operator=(Base &&) = delete;
    virtual ~Base ();
};
```
Или отнаследоваться приватным образом от ```nonmovable``` класса, где это запрещено. Экономит место в ``Base``, упрощает чтение. Полезно проектам с большим количеством классов.

```cpp
struct nonmovable {
    nonmovable() {}
    nonmovable(const nonmovable &) = delete;
    nonmovable(nonmovable &&) = delete;
    nonmovable &operator=(const nonmovable &) = delete;
    nonmovable &operator=(nonmovable &&) = delete;
};

struct Base : private nonmovable {
    virtual ~Base() {}
};
```

Запрет на операторы/конструкторы копирования/перемещения - не проблема, потому что обычно полиморфные объекты создают, чтобы в процессе выполнения писать базовый класс и почти не пользоваться наследованием. Обычно эти объекты не имеют автоматической времени жизни. Например, создают ``unique_ptr`` и взаимодействуют с объектом через него:
```cpp
std::unique_ptr <Base> b1(new Derived1);
```
Однако копирование такое не получится:
```cpp
std::unique_ptr <Base> b2(b1); // у указателя нет конструктора копирования
std::unique_ptr <Base> b2(new Base(*b1)); // нельзя, так как нужно указать
// конкретный динамический объект (new нужно знать сколько памяти выделить)
```
Выход - полиморфные функции.
```cpp
struct Base : private nonmovable {
    virtual ~Base() {}
    virtual std::unique_ptr<Base> clone() = 0;
};
```
``clone()`` выберет нужный конструктор копирования и вернет новый полиморфный объект. Реализуется(делает ``make_unique`` или оператор ``new``, возвращает копию правильного типа) по отдельности в каждом наследнике. Тогда верно:
```cpp
std::unique_ptr<Base> b2 = b1->clone();
```
*Где же ``clone()`` может пригодиться?*
Функция встречается редко, потому что такой иерархии объектов необязательно нужно копирование. Где нужно: графический редактор с возможностью копирования объектов.

*Почему нельзя просто юзать ``shared ptr``?*
Потому что он создает несколько указателей на один объект, а не создает несколько одинаковых объектов.

*Как реализовать ``clone()``?*
Вот так не получится, так как нет конструктора копирования:
```cpp
std::unique_ptr<Base> clone() override {
    return std::make_unique<Derived1>(*this);
}
```
Значит надо явно перечислять все поля
```cpp
struct Derived1 : Base {
    int x;

    Derived1() : x(100) {}
    Derived1(int x_) : x(x_) {}
protected:  // Derived11 этот конструктор тоже пригодится.
    Derived1(const Derived1 &other) : x(other.x) {}

public:
    std::unique_ptr<Base> clone() override {
        return std::make_unique<Derived1>(*this);
    }
};
```

*Реализация ``clone()`` без явного перечисления полей*:
- ``Base`` не наследовать от ``nonmovable``, сделать конструкторы и операторы protected. 
- Сделать конструктор копирования ``default``, остальные ``delete``.
- конструктор копирования ``Derived1`` сделать protected, чтобы компилятор не сгенерировал публичный конструктор копирования (иначе слайсинг).

```cpp
struct Base {
protected:
    Base() {}
    Base(const Base &) = default;

    Base(Base &&) = delete;
    Base &operator=(const Base &) = delete;
    Base &operator=(Base &&) = delete;

public:
    virtual ~Base() {}
    virtual std::unique_ptr<Base> clone() = 0;
};

struct Derived1 : Base {
    int x;
    Derived1() : x(100) {}
    Derived1(int x_) : x(x_) {}

protected:
    Derived1(const Derived1 &) = default;

public:
    std::unique_ptr<Base> clone() override {
        return std::make_unique<Derived1>(*this);
    }
};
```

**using**
Конструкторы по умолчанию не наследуются. Можно сделать
```cpp
struct Foo {
    Foo(int) {
    }
    Foo(double) {
    }
};

struct Bar : Foo {
    using Foo::Foo;
    // возьми все конструкторы из родителя
    // и сделай мне такие же
    // но для этого у полей должны быть значения по умолчанию
};

int main() {
    Foo(10);
    Foo(10.0);
    Bar(10);
    Bar(10.0);
}
```

**Паттерн "фабричная функция"**

Foo -- структура с приватным конструктором, хотим написать фабрику. Вызвать внутри просто ```make_unique``` не получится, тк он в свою очередь вызывает ```new```, ```new``` вызывает конструктор, который у нас приватный (```make_unique``` не является частью Foo и не имеет к доступа к private).
В качестве решения можно было бы попробовать объявить стандартную функцию ```std::make_unique``` другом, но мы не знаем ее точной реализации и не можем быть уверены, что ```make_unique``` вызывает new напрямую -- вдруг придется давать доступ к private методам еще кому-то... 
**Правильный вариант** руками создать чистый указатель и завернуть его в ```unique_ptr```.
```cpp
#include <memory>

struct Foo {
private:
    Foo() {}
public:    
    static std::unique_ptr<Foo> make_foo(){ //фабрика
        //неправильно:
        return std::make_unique<Foo>();
        
        //правильно:
        return std::unique_ptr<Foo>(new Foo());
    }
    
    //возможная попытка: 
    //friend void std::unique_ptr<Foo> std::make_unique<Foo>();
};
```
Где можно почитать: https://abseil.io/tips/134

### Взаимодействие наследования и шаблонов

В чем отличия между наследованием и такой конструкцией?
В наследовании нам нравилось, что можно конвертировать объект к ссылке на родителя. То же можно проэмулировать с помощью оператора неявной конвертации. 

```cpp
 struct Base {
    int x;
 };
 
 struct Derived {
    Base b;
    
    operator Base&() { return b; }
 };
 
 int main(){
    Derived d;
    d.b.x = 10;
    
    Base &b = d; //нравилось
    b.x = 20;
 }
```
 
Пропадают: виртуальные функции (но можно пытаться их реализовывать как-то по-другому), совметимость по указателям (конвертации по указателям не можем перегрузить, заложены в язык, но если достаточно конвертации по ссылкам, то, может, нам это подходит), красивый доступ к 'x'.
А еще пропадают шаблоны. 
```cpp
 template<typename T>
 struct Base {
    int x;
 };
 
 template<typename T>
 struct Derived1 : Base<T> {
 };
 
 template<typename T>
 struct Derived2 {
    Base<T> b;
    
operator Base<T>&() { return b; }
 };
 
 template<typename T>
 void foo(Base<T> &){
 }
 //с подстановкой int компилятор справится
 
 int main(){
    Derived1<int> d1;
    food(d1);
    
    Derived2<int> d2;
    foo(d2); //no
    foo<int>(d2); //yes
    
 }
```
 В таком случае можно использовать автовывод от T -- компилятор справляется. Но если делаем ''ядерный костыль'' с оператором конвертации -- уже ошибка компиляции: ''не удалось вывести аргумент T функции foo''. Можно указать тип T явно -- тогда ок (компилятор понимает, что ожидается Base от int, находит оператор приведения типа).
 Fun fact: у класса должно быть конечное фиксированное кол-во базовых классов.
 
### Друзья и ```protected```

Друзья работают только для фиксированного конкретного класса, к наследникам не переходят. foo имеет доступ только к полям своего прямого друга ```Derived1```. 

```cpp
 struct Base {
 private:
    int x = 0;
 };
 
 struct Derived1 : Base {
 private:
    int y = 0;
    friend void foo();
 };
 
 struct Derived2 : Derived1 {
 private:
    int z = 0;
 };
 
 void foo(){
    Derived2 d2;
    d2.x++; //нет доступа
    d2.y++; //есть
    d2.z++; //нет
 }
```
**Тут должно быть продолжение про протектед**

### Множественное наследование, виртуальное наследование, как с ним работают dynamic_cast/static_cast/неявное преобразование/override/hiding, cross-cast

**пример PieceOfArt**
Ex: произведение искусства было создано в какой-то момент. Можем создать мелодию и слова, из них составить песню.
```Song``` отнаследована от двух классов, следовательно, содержит все поля ```Music``` и все поля ```Lyrics```, тогда поле ```data``` внутри песни не мб однозначно определено, дату создания какого родителя надо брать? Используем специальный синтаксис (целиком путь до нужной структуры в цепочке наследования указывать необязательно).

```cpp
    struct PieceOfArt { std::chrono::time_point
                            <std::chrono::steady_clock> date; };
    struct Music : PieceOfArt {};
    struct Lyrics : PieceOfArt {};
    struct Song : Music, Lyrics {
        std::string album;
        //using Music::data; //можно так
        
        Song(....) : Music(....), Lyrics(....), album(....) { ... }
    };
    
    int main(){
        Song s;
        //auto x = s.date; //чью дату взять?
        auto x = s.Music::data;
        auto x = s.Lyrics::data;
        
        Music &m = s; //такое взятие ссылки меняет адрес объекта
        Lyrics &l = s;
        //PieceOfArt &p = s; //неоднозначно, нельзя
        PieceOfArt &p = static_cast<Music&>(s);
        
        std::cout << &s << '\n';
        std::cout << &m << '\n';
        std::cout << &l << '\n';
    }
```
Как хранится в памяти: сперва один родитель целиком, потом второй, потом наши поля. Если родители имеют несовместимые типы данных, они имеют разные адреса в памяти, что отразится на размере объекта класса, отнаследовавшегося от них обоих. 

**проблема ромбовидного наследования**
Не хотим, чтобы поля родителей дублировались каждый раз, когда создаются классы-наследники.
У магического студента, который одновременно и работает, и учится, два имени -- одно от ```Employee```, другое от ```Student```. Хотим добиться того, чтобы у ```MagicStudent``` было одно имя, один работодатель и одна учебная группа. 

```cpp
    struct Person { std::string name; };
    struct Employee : Person { std::string employer; };
    struct Student : Person { std::string group; };
    struct MagicStudent : Employee, Student {
        MagicStudent() : Person(), Employee(), Student() {}
    };
```
*Решение:* сделать наследование от ```Person``` виртуальным. Получаем: внутри ```Employee есть Person```, внутри ```Student``` есть ```Person```, внутри ```MagicStudent``` -- наследника их обоих -- также содержится одна копия ```Person```. Ссылки тоже работают.

```cpp
    struct Person { std::string name; };
    struct Employee : virtual Person { std::string employer; };
    struct Student : virual Person { std::string group; };
    struct MagicStudent : Employee, Student {};
    
    int main(){
        MagicStudent ms;
        ms.name = "Egor";
        
        Person &p = ms;
        Employee &e = ms;
        Student &s = ms;
    }
```
*Итак:* если есть класс, который нужно склеивать в наследниках, от него надо наследоваться виртуально.
*Как хранится в памяти?* Ддя удобства переобозначим классы ромбовидного наследования: ```A```= Person, ```B```= Employee, ```C```= Student, ```D``` = MagicStudent. Тогда внутри ```D``` независимо лежат объекты ```B``` и ```C```-- не пересекаются (они друг о друге ничего не знают). ```A``` тоже лежит внутри ```D```, но отдельно. Внутри ```B``` и внутри ```C``` есть есть указатель на этот ```A```.
Схоже с таблицей виртуальных функций. Сделано для того, чтобы можно было брать ссылки.
Таким образом при виртуальном наследовании внутри класса лежит ссылка на родителя и копия самого родителя, куда и указывает ссылка.
В конструкторе ```MagicStudent``` сперва инициализируются все виртуальные родители, потом dfs-проходом все остальные. Конструкторы ```Employee``` и ```Student``` уже не вызывают конструктор ```Person```.

**Посмотрим на методы при множественном наследовании**
Дано:
```cpp
struct Base {
    virtual void foo() = 0;
    virtual void bar() = 0;
};

struct Derived1 : Base {
    void foo() override {
    }
};

struct Derived2 : Base {
    void bar() override {
    }
};

struct DerivedX : Derived1, Derived2 {
};
```
``Base`` абстрактный класс, у него не определены ``foo()``, ``bar()``. ``Derived1`` абстрактный, в нем не определен ``bar()``, а в ``Derived2`` - ``foo()``. Их наследник ``DerivedX`` тоже абстрактный, потому что в нем два метода ``foo()`` и два метода ``bar()``, по одному из каждого предка. 2 из них чисто виртуальные, следовательно, он абстрактный.
Есть следующие проблемки:
```cpp
DerivedX *a = nullptr;
a->foo();
```
Потому что компилятор не понял, какую именно функцию вызвать: ``Derived1::foo()`` или ``Derived2::foo()``. (``ambigious``)
```cpp
a->Derived1::foo(); // Скомпилируется
a->Derived1::bar(); // undefined reference
// для компилятора у Derived1 нет метода bar()
```
*Что будет, если перезаписать метод ``foo()`` в ``DerivedX``?*
``override`` перезапишет ``foo()`` сразу изо всех базовых классов, даже без виртаульного наследования, неоднозначность исчезнет. Возвращаемое значение должно быть совместимым.

**Виртуальное наследование** убирает неоднозначность.
```cpp
struct Derived1 : virtual Base {
    void foo() override {
    }
};
struct Derived2 : virtual Base {
    void bar() override {
    }
};
struct DerivedX : Derived1, Derived2 {
};
```
*Почему виртуально от ``Base``, а не от ``Derived1``, ``Derived2``?* 
Тогда все плохо для такого примера:
```cpp
struct Base {
    int field = 100;
    virtual void foo() = 0;
    virtual void bar() = 0;
};
struct Derived1 : Base {
    void foo() override {
    }
};
struct Derived2 : Base {
    void bar() override {
    }
};
struct DerivedX : virtual Derived1, virtual Derived2 {
};
```
Поля ``field`` отдельно имеются у ``Derived1``, ``Derived1``. Тогда у их наследника имеется 2 таких поля.

**delegate to sister**
Прикол: ```Derived1``` может вызвать ``bar()`` из класса ``Derived2``, о котором он ничего не знает.
```cpp
struct Base {
    virtual void foo() {};
    virtual void bar() {};
};
struct Derived1 : virtual Base {
    void foo() override {
        bar(); 
    }
};
struct Derived2 : virtual Base {
    void bar() override {
    }
};
struct DerivedX : Derived1, Derived2 {
};
int main() {
    DerivedX a;
    a.foo();  // Derived1::foo() --> Base::bar() ~~ Derived2::bar()

    Derived1 b;
    b.foo();  // Derived1::foo() --> Base::bar()
}
```

**Кастуем с виртаульным наследованием**
Вот так не получится, так как ``static_cast`` работает на этапе компиляции, а нужно посмотреть внутрь объекта и узнать, где его содержимое:
```cpp
DerivedX a;
Base &b = a;
Derived1 &d1 = static_cast<Derived1 &>(b);
```
То есть с помощью ``static_cast`` нельзя переходить к наследникам, но можно к базовым классам.

С ``dynamic_cast`` можно:
```cpp
DerivedX a;
Base &b = a;
Derived1 &d2 = dynamic_cast<Derived1 &>(b);

// Так можно:
Derived1 &d1 = a;
Derived2 &d2 = dynamic_cast<Derived 2&>(static_cast<Base &>(d1));

// Так лучше:
DerivedX a;
Derived1 &d1 = a;
Derived2 &d2 = dynamic_cast<Derived2 &>(d1); // cross-cast
```

``dynamic_cast`` ходит по лесенке:
```cpp
// Не забыть виртуальный деструктор.
// Иначе не сможете владеть объектом по указателю на его базу,
// а тогда неясно, зачем вам вообще наследование (хотя может быть).
struct Base1 { virtual ~Base1() {} };
struct Base2 { virtual ~Base2() {} };
struct Base3 { virtual ~Base3() {} };

/*
  B1  B2  B3
  /\  /\  /\
 /  \/  \/  \
D1  12  23  D3
*/
struct Derived1 : virtual Base1 {};
struct Derived12 : virtual Base1, virtual Base2 {};
struct Derived23 : virtual Base2, virtual Base3 {};
struct Derived3 : virtual Base3 {};

struct DerivedX : Derived1, Derived12, Derived23, Derived3 {};

// Работает вот это:
DerivedX a;
Derived1 &d1 = a;
Derived3 &d3 = dynamic_cast<Derived3 &> (d1);
```

---

###  Проблема круга-квадрата и решения(circle-ellipse)
Можно почитать умную статью: [тык](https://isocpp.org/wiki/faq/proper-inheritance)

Рассмотрим такой функционал как get и set:
1) Пусть круг - частный случай эллипса:
```cpp
// OK

struct Circle {

    virtual void setRadius(int r);

};

struct Ellipse : Circle {

    virtual void setRadius(int r); // устанавливает w и h - нет противоречий
    virtual void setWidth(int w);
    virtual void setHeight(int h);

};

// WTF
struct Circle {
    virtual int getRadius();
};

struct Ellipse : Circle {
    virtual int getRadius() { ????????????? } // при различных w и h непонятно что возвращать
    virtual int getWidth();
    virtual int getHeight();
};
```

2) Пусть эллипс - частный случай круга:
```cpp
// OK
struct Ellipse {
    virtual int getWidth();
    virtual int getHeight();
};

struct Circle : Ellipse {
    int getRadius();
};
int getWidth(); //спокойно возвращают просто радиус, если круг
int getHeight();

// WTF

struct Ellipse {
    virtual void setWidth(int w);
    virtual void setHeight(int h);
};

struct Circle : Ellipse {
    virtual void setWidth() { ..... } // можем сделать что устанавливаем w и h радиусом
    void setRadius(int r);
};

//но ломается тест: 
Ellipse &e = ......
e.setWidth(10);
e.setHeight(20);
assert(e.width() == 10);
assert(e.height() == 20);
```

Итоговый вывод: бытовая/математическая логика не работает для программирования и нужно выбирать, что конкретно подходит под вашу программу, либо просто не использовать в данном случае наследование
### Ключевое слово  `mutable`  (`27-210513`)
**mutable** можем сделать таким поле класса и можно будет менять даже в const-qualified методах(когда это данные, которые имеют отношение только к реализации, но не к непосредственному использованию)

- mutex
```cpp
#include <mutex>

struct atomic_int {
int get() const {
   std::unique_lock l(m);
   return value;
}

void set(int new_value) {
    std::unique_lock l(m);
    value = new_value;

}
private:

mutable std::mutex m; 
int value;

};
```

- про матрицы
(чтобы каждый раз не считать по очень долго определитель, а кешировать значение -> ускорение)

```cpp
struct matrix {

int determinant() const {
  //первый раз считаем за куб, в остальных случаях берем уже вычисленное
}

private:
int n;
std::vector<int> data;
mutable std::optional<int> last_determinant;

};
```

### Использование  `const_cast`  для упрощения реализации (`30-210603`)
 - Для совместимости со старым кодом, чтобы отбрасывать const
 ```cpp
 void old_c_print_line(char *str) {
   printf("%s\n", str);
}

old_c_print_line(const_cast<char *>("hello"));
 ```
  - Для сокращения кода, чтобы выражать функции, реализовав самую строгую из них, а все остальные выразить через нее отбрасывая const
  ```cpp
T &get() & {
    return const_cast<T &>(std::as_const(*this).get());
}

T &&get() && {
    return std::move(get());
}

const T &get() const & { //основная реализация
    assert(initialized);
    return data;
}

// Incorrect implementation: поскольку 
/*
T& get() {
assert(initialized);
return data;
}
const T &get() const {
return const_cast<optional*>(this)->get();
}
*/
  ```
  
  > Казалось бы, при чем здесь наследование


### RTTI,  `typeid`,  `type_info`,  `boost::core::demangle`
**Run-Time-Type-Information** - информация, которую компилятор добавляет в бинарник для работы `dinamic_cast`, `typeid`, `type_info`. (Виртуальное наследование и виртуальные функции - отдельный механизм)
Можно отключить для сохранения места, если в программе этим не пользуемся. 
Для этого флаг: `-fno-rtti` , есть замены, `Boost::TypeIndex`

```cpp

#include <typeinfo>
#include <vector>
#include <boost/core/demangle.hpp> //красивая библиотека, которая умеет расшифровывать type_id в человечески-читаемый вид

// Важно, что Base полиморфный (есть хотя бы один виртуальный метод), иначе не включится RTTI.

// Тогда typeid() будет работать на этапе компиляции.

struct Base { virtual ~Base() {} };

struct Derived : Base {};

int foo() {
    std::cout << "foo()\n";
    return 10;
}

int main() {
    Base b;
    Derived d;

// RTTI: Run-Time Type Information.
// 1 - typeid(тип)
    const std::type_info &info_base = typeid(Base);
    const std::type_info &info_derived = typeid(Derived);
    const std::type_info &info_int = typeid(int);

// 2 - typeid(выражение)
    const std::type_info &info_int_expr = typeid(2 + 2 + foo()); // foo() не вызывается и само выражение не вычисляется
// 3
    const std::type_info &info_b = typeid(b);
    const std::type_info &info_d = typeid(d);
    std::cout << (info_base == info_b) << "\n";
    std::cout << (info_base == info_d) << "\n";
// std::type_index можно класть в set
    std::cout << info_int_expr.name() << "\n";
    std::cout << info_b.name() << "\n";
    std::cout << typeid(std::vector<int>).name() << "\n"; //выводит в каком-то страшном нечитабельном виде
    std::cout << boost::core::demangle(info_int_expr.name()) << "\n";
    std::cout << boost::core::demangle(info_b.name()) << "\n";
    std::cout << boost::core::demangle(typeid(std::vector<int>).name()) << "\n"; //умеет парсить красивее, но без гарантий

}
```

###  `initializer_list`, в том числе при рекурсивном list initialisation
Специальный тип, чтобы его писать в конструкторах единственным параметром

НО ! Все элементы константные -> нельзя мувать -> только копировать 

#### Пример кода: 
```cpp
struct Bar {

    Bar(std::initializer_list<int> x) {
        std::cout << x.size() << " " << *x.begin() << "\n";
    } //есть size и итератор

    Bar(std::initializer_list<Foo> x) {
        std::cout << x.size() << " " << x.begin()->val << "\n";
    }

    Bar([[maybe_unused]] std::initializer_list<std::unique_ptr<int>> x) {
// std::unique_ptr<int> y = std::move(*x.begin()); // Oops :( не можем так сделать из-за const
    }
};
```
Сделать дерево рекурсивной инициализации, где структура инициализируется либо от значения, либо от initializer_list. И сохраняем все в один вектор. 

#### Пример кода
```cpp
struct Baz {

    int val;

    std::vector<Baz> children;

    Baz(int val_) : val(val_) {
    }

    Baz(std::initializer_list<Baz> children_)
            : val(-1), children(children_.begin(), children_.end()) {
    }

    void print() const {
        if (val >= 0) {
            assert(children.empty());
            std::cout << val;
        } else {
            std::cout << "{";
            for (const auto &c : children)
                c.print();
            std::cout << "}";
        }
    }
};


Baz{
1, //
2, //
{3, 4}, //
{{5}}, //
{{6}, 7, {}}, //
8 //
}
.print();
```
Вывод .print(): {12{34}{{5}}{{6}7{}}8}
