## `decltype` и `decltype(auto)`

Помимо того, что иногда нам надо уметь делать "идеальную передачу" аргументов в некоторую функцию, порой нам хочется
делать "идеальное возвращение" значения, которое возвращает функция (например, если она возвращает значение, то вернём
значение, а если возвращает по ссылке, то и вернём мы из нашей обёртки тоже ссылку)

```c++
template <typename F, typename ...Ts>
   /*непонятно, что тут написать*/ logged(F f, Ts &&...args) {
   std::cout << "Before function invocation" << std::endl;
   return f(std::forward<Ts>(args)...);
}
```

Можно вспомнить про `auto`, но, к сожалению, он тут не поможет:

> Type deduction drops references

> Type deduction drops const qualifiers

Чтобы реализовать идеальное возвращение значения из функции, нужно понять, как работает `decltype`, который мы уже в
какой-то момент встречали (например, когда разговаривали про функторы и лямды)

```c++
int x = 10;
int &y = x;

decltype(10); // int
decltype(10 + 20); // int
decltype(x); // int
decltype(y); // int &
decltype(y + 20); // int
decltype((x)); // int &
```

Особое удивление наверняка вызывает `decltype((x))`, однако это вполне объяснимо, учитывая как работает `decltype`

### На самом деле, у него есть 2 режима работы:

1. `decltype(expression)` (вызываем `decltype` от выражения)
    1. `decltype(10)`
    2. `decltype((x))`
    3. `decltype(x + 20)`
2. `decltype(variable)` (вызываем `decltype` от какой-то переменной)
    1. `decltype(x)`

**В первом случае** он работает следующим образом:

1. Если то, что возвращает выражение -- это `prvalue`, то `decltype` нам вернёт сам тип `T`

2. Если то, что возвращает выражение -- это `lvalue`, то `decltype` нам вернёт `T&`

3. Если то, что возвращает выражение -- это `xvalue`, то `decltype` нам вернёт `T&&`

По сути, отдельно считаем тип и категорию выражения и из этого собираем тип, который возвращает

**Во втором случае** он работает очень просто: смотрит, с каким типом переменная была объявлена

Вот небольшие примеры того, как `auto` и `decltype(auto)` работают в выводе возвращаемого значения функции

```c++
int x;

auto foo() {
   // --> int foo()
   return x;
}

decltype(auto) bar() {
   // --> int bar (выводится int, так как 'x' был объявлен c типом int)
   return x;
}

decltype(auto) baz() {
   // --> int & baz() (выводится int&, так как тип выводится по правилам decltype)
   // это выражение
   return (x);
}

```

Напишем, как теперь выглядит идеальное возвращение значения со знанием правил работы `decltype`

```c++
template <typename F, typename ...Ts>
decltype(auto) logged(F f, Ts &&...args) {
   std::cout << "Before function invocation" << std::endl;
   return f(std::forward<Ts>(args)...);
}
```

А ещё всё это можно написать в виде лямбды

```c++
auto logged =[&](auto f, auto &&...args) -> decltype(auto) {
   std::cout << "Before function invocation" << std::endl;
   return f(std::forward<decltype(args)>(args)...);
};
```

## Указатель на члены класса

Иногда может хотеться сохранить указатель на какой-то член класса в переменную.

Рассмотрим пример, как такое можно сделать

```c++
struct S {
  int x = 1;
  int y = 2;
  int foo(int t) { return x + y + t; }
  int bar(int t) const { return x + y + t + 10; }
};

S obj;
// создаём указатель a на поле 'x' класса S
int (S::*a) = &S::x;
// создаём указатель b на поле 'y' класса S
int (S::*b) = &S::y;
```

Синтаксис, безусловно, крайне упоротый. Но это ещё не всё! Вот как можно обращаться к полю, которое лежит по этому
указателю

```c++
int x1 = obj.*a;
S *objptr = &obj;
int y1 = objptr->*b;
```

Кстати, их тоже можно переприсваивать

```c++
a = b;
// теперь мы так обращаемся к полю 'y', а не 'x'
obj.*a;
```

В целом, аналогично полям можно работать с указателями на методы класса

```c++
int (S::*fooptr)(int) = &S::foo;
std::cout << (obj.*fooptr)(10) << std::endl;
```

**С указателями на методы важно не забывать сохранять const-qualifier**

```c++
int (S::*barptr)(int) const = &S::bar;
```

Кстати, возникают все стандартные проблемы с перегрузками.

Это всё, конечно, очень задорно и весело, можно пугать детей и всё такое, но **зачем???**

Ну оказывается, что с помощью этого механизма удобно писать какие-нибудь сериализаторы.

Кстати говоря, указатели на члены несовместимы с обычными указателями

1. Указатель на поле -- это сдвиг внутри объекта. Это не `void*` и не указатель на объект
2. Указатель на метод несовместим даже с обычными указателями на функцию
   1. Бывают виртуальные функции и виртуальное наследование
   2. Надо поддерживать преобразования по иерархии


## SFINAE

Для начала, **SFINAE** расшифровывается как **S**ubstitution **F**ailure **I**s **N**ot **A**n **E**rror

Общий смысл таков: если при подстановке шаблонных параметров в сигнатуру функции произошла ошибка, то компилятор просто 
считает, что этой перегрузки как бы нет. Моментальной ошибки компиляции не происходит, 
она может возникнуть потом, если ни одна перегрузка не подойдёт.

Например, это вполне валидный пример того, что SFINAE действительно работает

```c++
template<typename T>
void duplicate_element(T &container, typename T::iterator iter) {
    container.insert(iter, *iter);
}

template<typename T>
void duplicate_element(T *array, T *element) {
   assert(array != element);
   *(element - 1) = *element;
}

std::vector a{1, 2, 3};
duplicate_element(a, a.begin() + 1);
int b[] = {1, 2, 3};
duplicate_element(b, b + 1); // Нет ошибки, когда пробуем первую перегрузку: не бывает int[]::iterator, но это не ошибка компиляции. SFINAE.
```

Вот ещё пример корректного использования SFINAE

```c++
struct BotvaHolder {
    using botva = int;
};

template<typename T> using GetBotva = typename T::botva;

template<typename T>
void foo(T, GetBotva<T>) {  // Просто псевдоним, так можно, проблемы возникают как бы "тут".
    std::cout << "1\n";
}

template<typename T>
void foo(T, std::nullptr_t) {
    std::cout << "2\n";
}

 foo(BotvaHolder(), 10);  // 1
 foo(BotvaHolder(), nullptr);  // 2
 // foo(10, 10);  // CE
 foo(10, nullptr); // 2
```

Тут в случае, когда мы подставляем std::nullptr_t в качестве типа `T`, происходит ошибка при подстановке в сигнатуру
функции, ведь у std::nullptr_t нет внутреннего типа `botva`.

А в случае с `foo(10, 10)` не получится найти ни одной корректной перегрузки и поэтому произойдёт CE.

Теперь рассмотрим случай, когда задуманное не работает, то есть, когда мы думаем, что используем SFINAE, но, оказывается, что не совсем.

```c++
struct BotvaHolder {
    using botva = int;
};

template<typename T>
struct GetBotva {
    using type = typename T::botva;  // hard compilation error.
};

template<typename T>
void foo(T, typename GetBotva<T>::type) {  // Ошибка компиляции, потому что проблема возникла уже внутри GetBotva.
    std::cout << "1\n";
}

template<typename T>
void foo(T, std::nullptr_t) {
    std::cout << "2\n";
}

 foo(BotvaHolder(), 10);  // 1
 foo(BotvaHolder(), nullptr);  // 2
 // foo(10, 10);  // CE
 foo(10, nullptr); // 2
```

В данном случае у нас не работает SFINAE, так как в сравнении с предыдущим примером 
у нас ошибка произойдёт при попытке инстанцировать шаблонную структуру `GetBotva` on `int`. 
То есть, идея в том, что мы уже попытаемся внутри этой структуры залезть в `int::botva`, 
что вызовет ошибку компиляции, но это не приведёт к тому, что эта перегрузка просто не будет рассмотрена. 
Это приведёт к моментальной ошибке компиляции, чего мы вряд ли хотели