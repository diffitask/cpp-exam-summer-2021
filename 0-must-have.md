# Обязательные знания
Если вы не знаете какие-то термины что-то из списка ниже, это автоматический неуд.

## Термины

### Свободная функция, функция-член

Функция-член: объявлена в классе/структуре и принадлежит классу/структуре. Свободная функция это любая функция, не являющаяся фнукцией-членом, то есть объявленная вне класса/структуры.

### Время жизни объекта: автоматическое, динамическое, статическое

Automatic: объект автоматически привязан к охватывающей области и будет автоматически уничтожен при выходе из этой области.

Dinamic: время жизни объекта под непосредственным контролем пользователя

Static: объект начинает жить, когда программа запускается и заканчивает жизнь с концом ее работы.

### Undefined behavior: что может произойти, примеры

Необъяснимое поведение программы, возвращаются загадочные результаты, поведение программы не предсказуемо. Возникает, если выходить за границы массива, обращаться к неинициализированной переменной, etc перечислено в билетах, то есть делать вещи, которые не могут сходу отловиться компилятором плюсов, но вообще являются ошибкой.

## Переменные

Каждая переменная имеет **тип**, определяющий, какие значения она может принимать и какие операции с ней разрешены. 

C++ - **статически типизированный** язык: тип переменной указывается при ее объявлении, его нельзя изменить в ходе программы. Это позволяет проверять типы данных на этапе компиляции, а не во время выполнения программы.

**Размер переменной** - количество байт, которые она занимает в памяти. Размер переменной зависит от ее типа. Причем **размер типа** на разных архитектурах в разных компиляторах различен. Оператор `sizeof(type)` возвращает размер типа `type`, `sizeof expr` возвращает размер типа выражения `expr`, если его можно вычислить.

Например, на архитектуре `x86_64` под Linux в компиляторе `GCC` тип `int` занимает 4 байта, тип `char` занимает 1 байт.

## Основные конструкции языков C и C++
* объявления переменных
* выражения и операторы:
  * арифметические (`+`, `-`, `*`, `/`, `%`, `+=`, `-=`, `*=`, `/=`, `%=`, `++`, `--`)
  * булевы (`<`, `<=`, `>`, `>=`, `==`, `!=`, `&&`, `||`, `!`)
  * на минимальную оценку необязательно знать: отличия постфиксных и префиксных операторов
* условный оператор `if`
* циклы `for`, `while`

## Функции
**Объявление** функции информирует компилятор о названии функции, вовзвращаемом типе и аргументах. Если функция не возвращает значение, указывается тип возврата `void`. 

**Определение** функции содержит алгоритм, совершаемый при ее вызове. Оператор `return` указывает значение, которое будет возвращаться.

**Вызов функции**: `function_name.()`, `function_name.(arg1, arg2)`. Если функция имеет параметры по умолчанию, их можно не передавать. 

**Рекурсия** - определение функции через саму себя. 

## Основные конструкции С++

### синтаксис static_cast

`static_cast < new_type > ( expression )`  

Собственно, меняет тип того, что внутри круглых скобочек на тип того, что в угловых скобочках, то есть делает каст элеимента одного типа к другому. 

### синтаксис объявления пространств имён, обращения к элементу внутри пространства имён
```c++
namespace bank {
  void get_money() {};
}
  
  ...
  
bank::get_money();
```
  
### auto для объявления переменных

https://docs.microsoft.com/ru-ru/cpp/cpp/auto-cpp?view=msvc-160

### range-based for, в том числе с auto& и const auto&

можно написать очень много разных конструкций, подробнее на https://en.cppreference.com/w/cpp/language/range-for

мы обычно используем, чтобы ходить по элементам контейнера без обращения к их индексам

```c++
for (auto& i : v) {
...
}
for (const auto& i : v) {
...
}
```
### синтаксис шаблонов, достаточный для написания минимального адаптера stack<T> поверх deque
  
`template<typename T>`
структура/функция

а подробно [тут](https://drive.google.com/drive/folders/11Mdp0R46nY-dklE8ycUkGxPbZckeic6Y)

## Классы
**Класс** - пользовательский тип данных.

**Метод** класса - функции, определенные внутри класса.

**Конструктор** - метод класса, вызывающийся при создании объекта.

**Деструктор** - метод, вызывающийся при удалении объекта.

**Пять специальных методов**:
* конструктор копирования;
* конструктор перемещения;
* оператор копирования;
* оператор перемещения;
* деструктор.

**Правило пяти**: Если в классе потребовалось определить какой-то из специальных методов, то, скорее всего, потребуется определить все пять.

**Правило нуля**: Не определять никакой из этих пяти методов, поручить это компилятору. Для владения ресурсами использовать умные указатели вместо обычных.

В C++ есть 3 уровня доступа: 
* спецификатор **public**: доступ к членам даже извне класса;
* спецификатор **private**: доступ имеют только другие члены этого класса;
* спецификатор **protected**: открывает доступ только для дружественных и дочерних классов.

## Const correctness

**синтаксис константных ссылок, применение при передаче аргументов**

Константная ссылка на объект - часто очень удобный способ передать аргумент в функцию: при этом не происходит копирования, но и менять передаваямый объект мы не разрешаем. Поэтому, вместо передачи по значению или по обычной ссылке лучше использовать const ссылку(за исключением случаев, когда можно вместо этого передать по значению и сделать `std::move`, что потребует столько же копирований, как если бы мы передали const-ссылку и скопировали объект на который она ссылается)
Пример использования константной ссылки для конструктора:
```c++ 
struct Foo{
  char first_symbol;
  Foo(const std::string& str){
    assert(!str.empty());
    first_symbol = str[0];
  }
}; 
```
заметим, что при этом не происходит копирования всей строки, поэтому мы создаем объект класса Foo за O(1)

**невозможность изменять константные объекты и их поля**

Ключевое слово `const` говорит нам о том, что объект нельзя изменять - переменная, помеченная `const` не может меняться, а у объекта класса помеченного `const` можно вызывать только методы помеченные const-quilifier-ом(которые не меняют поля класса, если они не `mutable`)
Осторожно с указателями, слово `const` можно написать в разных местах, и от этого будет зависеть его значение:
* `const X* p` значит, что p указывает на константный объект - сам указатель можно менять, объект - нет
* `X* const p` значит, что p - константный указатель на неконстантный объект X. То есть менять объект можно, а указатель нет.
* `const X* const p` Значит, что мы берем указатель на константный объект, при этом сам указатель тоже константный. То есть не менять указатель, ни объект по нему, мы не можем

**const-qualifier у методов (const member function), перегрузка по const-qualifier (const overloading)**

При объявлении функции класса можно написать const-qualifier(например `const int& get_int() const`), и тогда это будет означать, что этот метод не меняет поля класса. Это, например, может пригодиться, если мы хотим работать с константным объектом, и хотим вызывать у него какие-то методы, если const-quilifier-a не будет, то метод нельзя будет вызвать, так как он(по мнению компилятора) может менять состояние класса. Поэтому в классах методы можно перегружать по const-quilifier, чтобы в одном случае мы могли менять объект класса, а в другом - нет. Типичный ример - `operator[]` - в одном случае мы хотим получить только элемент и 'посмотреть на него', а в другом - поменять. Для этого необходимо(чаще всего) этот оператор перегружать двумя способами: <code>const T& operator[](size_t i) const</code> и <code>T& operator[](size_t i)</code>  
## Использование move-семантики
Подробный рассказ про move-семантику и категории значений можно найти [тут](https://drive.google.com/file/d/1Pq5aPj6sIkDfRrXDEqX57DS-ZUWkJsYJ/view?usp=sharing)

**эффективная инициализация полей класса из аргументов, принятых по значению или по rvalue-ссылке:**

Если в конструктор принимается объект по значению, то, чтобы избежать излишнего копирования, мы можем сделать `std::move`. В таком случае мы не испортим объект который передавался, так как он при передаче в конструктор все равно копировался. При передаче по rvalue ссылке тоже можно делать move, так как считается что объект временный и его можно спокойно портить(а конкретнее: он может оказаться в moved-from состоянии)

**moved-from состояние у объектов:**

После перемещения, согласно move-семантике объект остается в каком-то корректном состоянии, однако абсолютно не гарантируется в каком. То есть при написании <code>vector v1 = std::move(v2)</code>, неизвестно что будет в векторе `v2`, он будет в неопределенном, но корректном состоянии, поэтому после перемещения стоит, в этом случае сделать <code>v2.clear()</code> и работать с вектором в определенном состоянии

**отсутствие необходимости `move` из результата функции, возвращённого по значению:**

`move` возвращаемого из функции значения стоит писать только если мы хотим вернуть `rvalue`, в противном случве писать `std::move` не нужно и даже плохо, так как этот `move` может отключить Return-value-optimization, если она там включалась, а если нет, то мы просто сделали лишнее перемещение непонятно зачем, так как функция все равно возвращает значение, то это ничего не даст.

**необходимость move для явной передачи владения `unique_ptr`**

`unique_ptr` может иметь лишь одного прямого владельца, поэтому у него запрещены копирующие оператор присваивания и конструктор. Чтобы передать владение `unique_ptr` необходимо сделать `move`, чтобы сохранить этот инвариант. Старый владелец перейдет в moved-from состояние и перестанет ссылаться на изначальный объект.

**почему `std::move` не выполняет никакого кода**   

`std::move` по сути просто меняет категорию значения, и аналогичен обычному `static_cast<T&&>`, поэтому он не выполняет никакого кода


## STL
**использование `vector` как динамического массива фиксированной длины, <code>push_back</code> и <code>emplace_back</code>**

`std::vector` - стандартный контейнер, который позволяет работать с ним как с динамическим массивом. При этом он реализован с использованием статического массива, поэтому все элементы в нем лежат в памяти подряд, и по нему легко можно итерироваться. Для добавления элемента в конец используется 2 метода - `push_back` и `emplace_back`. Их различие в том, что в `push_back` передается сам элемент, а в `emplace_back` - только парметры его конструктора, с помощью которых `vector` сам создаст элемент в конце массива без использования лишних копирований и перемещений.
Важно помнить, что при добавлении и удалении из `vector` может произойти инвалидация итераторов - в первом случае из-за возможного переаллоцирования памяти, во втором - из-за удаления элемента, на который был взят итератор.

**использование `map` со стандартным компаратором, особенность <code>operator[]</code> (создаёт значение даже при чтении)**

`std::map` - тоже стандартный контейнер, хранящий пары уникальный ключ - значение в отсортированном порядке. Порядок сортировки по умолчанию задается стандартным компаратором, то есть, если элементы типа ключ можно сравнивать, то они будут в отсортирванном порядке. Если же нельзя - то надо задавать свой компаратор и передавать его в `map`.
В `map` инвалидации итераторов не происходит, поскольку она построена на одном из деревьев поиска, поэтому при добавлении итераторы не инвалидируются, хоть и дерево как-то меняется(при удалении инвалидируется только итератор на удаляемый элемент)
При этом необходимо помнить, что при вызове оператора `[]`  если нужного ключа не было, то все равно создастся объект с дефолтным конструктором(чтобы этого избежать нужно сначала проверять есть ли объект в `map`)
## TODO: второй семестр
