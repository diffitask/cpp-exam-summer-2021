# Обязательные знания
Если вы не знаете какие-то термины что-то из списка ниже, это автоматический неуд.

## Термины
* Свободная функция, функция-член
* Время жизни объекта: автоматическое, динамическое, статическое
* Undefined behavior: что может произойти, примеры:
  * Неинициализированная переменная: почему у неё нет никакого значения.
  * Выход за границы массива.
  * Dangling reference (висячая ссылка) при возврате из функции, при инвалидации в стандартном контейнере.
  * Разыменование `nullptr`.

## Переменные

Каждая переменная имеет **тип**, определяющий, какие значения она может принимать и какие операции с ней разрешены. 

C++ - **статически типизированный** язык: тип переменной указывается при ее объявлении, его нельзя изменить в ходе программы. Это позволяет проверять типы данных на этапе компиляции, а не во время выполнения программы.

**Размер переменной** - количество байт, которые она занимает в памяти. Размер переменной зависит от ее типа. Причем **размер типа** на разных архитектурах в разных компиляторах различен. Оператор `sizeof(type)` возвращает размер типа `type`, `sizeof expr` возвращает размер типа выражения `expr`, если его можно вычислить.

Например, на архитектуре `x86_64` под Linux в компиляторе `GCC` тип `int` занимает 4 байта, тип `char` занимает 1 байт.

## Основные конструкции языков C и C++
* объявления переменных
* выражения и операторы:
  * арифметические (`+`, `-`, `*`, `/`, `%`, `+=`, `-=`, `*=`, `/=`, `%=`, `++`, `--`)
  * булевы (`<`, `<=`, `>`, `>=`, `==`, `!=`, `&&`, `||`, `!`)
  * на минимальную оценку необязательно знать: отличия постфиксных и префиксных операторов
* условный оператор `if`
* циклы `for`, `while`

## Функции
**Объявление** функции информирует компилятор о названии функции, вовзвращаемом типе и аргументах. Если функция не возвращает значение, указывается тип возврата `void`. 

**Определение** функции содержит алгоритм, совершаемый при ее вызове. Оператор `return` указывает значение, которое будет возвращаться.

**Вызов функции**: `function_name.()`, `function_name.(arg1, arg2)`. Если функция имеет параметры по умолчанию, их можно не передавать. 

**Рекурсия** - определение функции через саму себя. 

## Основные конструкции C++
* синтаксис `static_cast`
* синтаксис объявления пространств имён, обращения к элементу внутри пространства имён
* `auto` для объявления переменных
* range-based for, в том числе с `auto&` и `const auto&`
* синтаксис шаблонов, достаточный для написания минимального адаптера `stack<T>` поверх `deque`

## Классы
**Класс** - пользовательский тип данных.

**Метод** класса - функции, определенные внутри класса.

**Конструктор** - метод класса, вызывающийся при создании объекта.

**Деструктор** - метод, вызывающийся при удалении объекта.

**Пять специальных методов**:
* конструктор копирования;
* конструктор перемещения;
* оператор копирования;
* оператор перемещения;
* деструктор.

**Правило пяти**: Если в классе потребовалось определить какой-то из специальных методов, то, скорее всего, потребуется определить все пять.

**Правило нуля**: Не определять никакой из этих пяти методов, поручить это компилятору. Для владения ресурсами использовать умные указатели вместо обычных.

В C++ есть 3 уровня доступа: 
* спецификатор **public**: доступ к членам даже извне класса;
* спецификатор **private**: доступ имеют только другие члены этого класса;
* спецификатор **protected**: открывает доступ только для дружественных и дочерних классов.

## Const correctness
* синтаксис константных ссылок, применение при передаче аргументов
* невозможность изменять константные объекты и их поля
* const-qualifier у методов (const member function), перегрузка по const-qualifier (const overloading)

## Использование move-семантики
* эффективная инициализация полей класса из аргументов, принятых по значению или по rvalue-ссылке
* moved-from состояние у объектов: может быть не определено, может быть невозможно обнаружить, пример ошибки
* отсутствие необходимости `move` из результата функции, возвращённого по значению
* необходимость move для явной передачи владения `unique_ptr`
* почему `std::move` не выполняет никакого кода

## STL
* использование `vector` как динамического массива фиксированной длины, <code>push_back</code> и <code>emplace_back</code>
* использование `map` со стандартным компаратором, особенность <code>operator[]</code> (создаёт значение даже при чтении)

## TODO: второй семестр
